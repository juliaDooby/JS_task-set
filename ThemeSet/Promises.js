---------------------------------------------------------------------------------------------
⋙ ❍ Работа с Promises (асинхронным кодом):
---
1. Создание простого промиса
⌛ Задача: Создайте `Promise`, который выполняется через 1 секунду и возвращает строку `"Resolved"`.
🎯 Решение:
```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Resolved");
  }, 1000);
});

promise.then(result => console.log(result)); // "Resolved"
```
Объяснение: `resolve` используется для успешного завершения промиса, а `reject` для ошибок.
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
2. Обработка ошибки
⌛ Задача: Обработайте ошибку в следующем коде.
```javascript
const promise = new Promise((resolve, reject) => {
  reject("Error occurred");
});

promise
  .then(result => console.log(result))
  .catch(error => console.log(error));
```
🎯 Решение:
```javascript
// Вывод: "Error occurred"
```
Объяснение: Метод `catch` используется для обработки ошибок.
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
3. Цепочка промисов
⌛ Задача: Используйте цепочку промисов, чтобы последовательно выполнить три шага.
🎯 Решение:
```javascript
new Promise(resolve => resolve(1))
  .then(result => {
    console.log(result); // 1
    return result + 1; // Передаём 2 в следующий then
  })
  .then(result => {
    console.log(result); // 2
    return result + 1; // Передаём 3 в следующий then
  })
  .then(result => {
    console.log(result); // 3
  })
  .catch((error) => {
    console.error("Ошибка:", error); // Ловим возможные ошибки
  });
```
Объяснение:
1. Создание промиса:
   ```javascript
   new Promise((resolve) => resolve(1))
   ```
   - Мы создаём новый `Promise`, который сразу же выполняется (`resolve(1)`).
   - Это означает, что первый `.then()` получит `1` в качестве `result`.
2. Первый `.then()`:
   ```javascript
   .then((result) => {
     console.log(result); // 1
     return result + 1; // Возвращаем 2
   })
   ```
   - Логируем `1` в консоль.
   - Возвращаем `result + 1`, то есть `2`, и передаём его в следующий `.then()`.
3. Второй `.then()`:
   ```javascript
   .then((result) => {
     console.log(result); // 2
     return result + 1; // Возвращаем 3
   })
   ```
   - Логируем `2` в консоль.
   - Возвращаем `3`, который передаётся в следующий `.then()`.
4. Третий `.then()`:
   ```javascript
   .then((result) => {
     console.log(result); // 3
   })
   ```
   - Логируем `3` в консоль.
   - Мы не возвращаем ничего, так как это последний шаг цепочки.
5. Обработка ошибок (`.catch()`):
   ```javascript
   .catch((error) => {
     console.error("Ошибка:", error);
   });
   ```
   - Если в любом `.then()` произойдёт ошибка, она будет поймана в `.catch()`, и мы увидим сообщение в консоли.
Каждый `then` возвращает новый `Promise`, который можно обработать в следующем `then`.
---
Вывод в консоли:
```
1
2
3
```
Почему это важно?
- Это показывает, как промисы позволяют управлять последовательным выполнением асинхронного кода.
- `.then()` возвращает значение, которое передаётся следующему `.then()`, создавая цепочку.
- `.catch()` обрабатывает возможные ошибки в любом шаге цепочки.
Этот подход широко используется при работе с API-запросами, асинхронными операциями и потоками данных в JavaScript.
---
Кратко:
```javascript
new Promise((resolve) => resolve(1))
  .then((result) => {
    console.log(result); // 1
    return result + 1;
  })
  .then((result) => {
    console.log(result); // 2
    return result + 1;
  })
  .then((result) => console.log(result)) // 3
  .catch((error) => console.error("Ошибка:", error));
```
Объяснение:
1. `resolve(1)` – создаём промис и сразу передаём `1` в цепочку.
2. Первый `.then()` – логируем `1`, передаём `2` дальше.
3. Второй `.then()` – логируем `2`, передаём `3` дальше.
4. Третий `.then()` – логируем `3`, завершаем цепочку.
5. `.catch()` – обрабатывает ошибки, если они появятся.
---
Вывод в консоли:
```
1
2
3
```
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
4. Promise.all
⌛ Задача: Как использовать `Promise.all`, чтобы дождаться выполнения всех промисов?
🎯 Решение:
```javascript
const promise1 = Promise.resolve(1);
const promise2 = Promise.resolve(2);
const promise3 = Promise.resolve(3);

Promise.all([promise1, promise2, promise3]).then(results => {
  console.log(results); // [1, 2, 3]
});
```
Объяснение: `Promise.all` ждёт выполнения всех переданных промисов и возвращает массив их результатов.
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
5. Promise.all с ошибкой
⌛ Задача: Что произойдёт, если один из промисов завершится с ошибкой?
```javascript
const promise1 = Promise.resolve(1);
const promise2 = Promise.reject("Error");
const promise3 = Promise.resolve(3);

Promise.all([promise1, promise2, promise3])
  .then(results => console.log(results))
  .catch(error => console.log(error));
```
🎯 Решение:
```javascript
"Error"
```
Объяснение: Если один из промисов завершится с ошибкой, `Promise.all` сразу перейдёт в состояние `rejected`.
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
6. Promise.race
⌛ Задача: Используйте `Promise.race`, чтобы получить результат самого быстрого промиса.
🎯 Решение:
```javascript
const promise1 = new Promise(resolve => setTimeout(() => resolve("First"), 1000));
const promise2 = new Promise(resolve => setTimeout(() => resolve("Second"), 500));

Promise.race([promise1, promise2]).then(result => console.log(result)); // "Second"
```
Объяснение: `Promise.race` возвращает результат первого завершившегося промиса.
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
7. Наследование ошибок
⌛ Задача: Что произойдёт, если ошибка не будет обработана в одном из `then`?
```javascript
Promise.resolve(1)
  .then(result => {
    throw new Error("Something went wrong");
  })
  .then(result => console.log(result))
  .catch(error => console.log(error.message));
```
🎯 Решение:
```javascript
"Something went wrong"
```
Объяснение: Если ошибка выброшена внутри `then`, она будет поймана в ближайшем `catch`.
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
8. finally
⌛ Задача: Как использовать `finally` для выполнения кода независимо от результата промиса?
🎯 Решение:
```javascript
Promise.resolve("Success")
  .then(result => console.log(result))
  .catch(error => console.log(error))
  .finally(() => console.log("Finally executed"));
```
Результат:
```
"Success"
"Finally executed"
```
Объяснение: `finally` выполняется независимо от успешного или неуспешного завершения промиса.
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
9. Цепочка ошибок
⌛ Задача: Что выведет следующий код?
```javascript
Promise.reject("Error")
  .then(result => console.log(result))
  .catch(error => {
    console.log(error);
    throw new Error("New Error");
  })
  .catch(error => console.log(error.message));
```
🎯 Решение:
```
"Error"
"New Error"
```
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
10. Создание задержки
⌛ Задача: Напишите функцию `delay`, которая возвращает промис, разрешающийся через заданное количество миллисекунд.
🎯 Решение:
```javascript
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

delay(1000).then(() => console.log("1 second passed"));
```
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
11. Последовательное выполнение
⌛ Задача: Как выполнить промисы последовательно?
🎯 Решение:
```javascript
const tasks = [1, 2, 3];

tasks.reduce((promise, task) => {
  return promise.then(() => {
    console.log(task);
    return Promise.resolve();
  });
}, Promise.resolve());
```
Результат:
```
1
2
3
```
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
12. Обработка ошибок в цепочке
⌛ Задача: Где нужно разместить `catch`, чтобы обработать любую ошибку?
🎯 Решение:
```javascript
Promise.resolve(1)
  .then(() => {
    throw new Error("First error");
  })
  .then(() => {
    throw new Error("Second error");
  })
  .catch(error => console.log(error.message)); // Ловит первую ошибку
```
Результат:
```
"First error"
```
Объяснение:
1. `Promise.resolve(1)` — создаёт промис, который сразу переходит в состояние `fulfilled` с результатом `1`.
2. Первый `.then()` — выбрасывает ошибку (`throw new Error("First error")`).
   - Из-за этого `Promise` немедленно переходит в состояние `rejected`.
3. Второй `.then()` не выполняется — потому что ошибка в предыдущем `.then()` прерывает цепочку.
4. `.catch(error => console.log(error.message))`*
   - Перехватывает первую ошибку `"First error"`, так как `.catch()` ловит первое `rejected` состояние в цепочке.
   - Ошибка `"Second error"` не выбрасывается, так как до неё выполнение не доходит.
Вывод в консоли:
```
First error
```
Как обработать ошибки на каждом этапе?
Если нужно обработать ошибки на каждом `.then()`, нужно добавить `.catch()` после каждого шага:
```javascript
Promise.resolve(1)
  .then(() => {
    throw new Error("First error");
  })
  .catch(error => {
    console.log("Caught in first catch:", error.message);
  })
  .then(() => {
    throw new Error("Second error");
  })
  .catch(error => {
    console.log("Caught in second catch:", error.message);
  });
```
Вывод в консоли:
```
Caught in first catch: First error
Caught in second catch: Second error
```
Теперь каждая ошибка обрабатывается отдельно.
Вывод:
- Один `catch` в конце цепочки — ловит только первую ошибку.
- Несколько `catch` на каждом этапе — ловят ошибки на каждом `.then()` по отдельности.
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
13. Повторная попытка промиса
⌛ Задача: Напишите функцию, которая повторяет промис 3 раза, если он завершается с ошибкой.
🎯 Решение:
```javascript
function retry(promiseFn, retries) {
  return promiseFn().catch(error => {
    if (retries > 0) {
      return retry(promiseFn, retries - 1);
    }
    throw error;
  });
}

retry(() => Promise.reject("Error"), 3).catch(error => console.log(error));
```
Результат:
```
"Error"
```
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
14. Промис с состоянием
⌛ Задача: Как узнать состояние промиса?
🎯 Решение:
```javascript
const promise = Promise.resolve(1);

promise
  .then(result => {
    console.log("Resolved:", result);
  })
  .catch(error => {
    console.log("Rejected:", error);
  });
```
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
15. Promise.any
⌛ Задача: Как использовать `Promise.any`?
🎯 Решение:
```javascript
const promise1 = Promise.reject("Error");
const promise2 = Promise.resolve("Success");

Promise.any([promise1, promise2]).then(result => console.log(result)); // "Success"
```
Объяснение: `Promise.any` возвращает первый успешно выполненный промис.
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
16. Параллельная обработка с результатами
⌛ Задача: Получите массив результатов промисов, включая ошибки.
🎯 Решение:
```javascript
const promise1 = Promise.resolve(1);
const promise2 = Promise.reject("Error");

Promise.allSettled([promise1, promise2]).then(results => console.log(results));
```
Результат:
```javascript
[
  { status: "fulfilled", value: 1 },
  { status: "rejected", reason: "Error" }
]
```
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
17. Использование async/await
⌛ Задача: Напишите функцию, которая последовательно выполняет два промиса с использованием `async/await`.
🎯 Решение:
```javascript
async function execute() {
  const result1 = await Promise.resolve(1);
  console.log(result1);

  const result2 = await Promise.resolve(2);
  console.log(result2);
}

execute();
```
Результат:
```
1
2
```
---------------------------------------------------------------------------------------------

CHECK DUBLES!!!
Эти задачи помогут вам потренировать базовые операции с числами, строками и массивами, улучшив навыки работы с последовательными алгоритмами в JavaScript.
1️⃣ Проверка наличия числа в массиве
⌛ Задача: Напишите функцию, которая проверяет, есть ли число в массиве.
🎯 Решение:
```js
function contains(arr, num) {
  return arr.includes(num);
}

console.log(contains([1, 2, 3, 4], 3)); // true
console.log(contains([1, 2, 3, 4], 5)); // false
```
Объяснение: Мы используем метод `includes`, чтобы проверить наличие элемента в массиве.
---
2️⃣ Нахождение минимального числа
⌛ Задача: Напишите функцию, которая находит минимальное число из массива.
🎯 Решение:
```js
function findMin(arr) {
  return Math.min(...arr);
}

console.log(findMin([10, 2, 33, 4])); // 2
```
Объяснение: Для нахождения минимального числа используем встроенную функцию `Math.min` с распаковкой массива с помощью оператора `...`.
---
3️⃣ Проверка, является ли число положительным
⌛ Задача: Напишите функцию, которая проверяет, является ли число положительным.
🎯 Решение:
```js
function isPositive(num) {
  return num > 0;
}

console.log(isPositive(5)); // true
console.log(isPositive(-3)); // false
```
Объяснение: Мы проверяем, больше ли число нуля. Если да, то оно положительное.
---
4️⃣ Подсчет количества пробелов в строке
⌛ Задача: Напишите функцию, которая подсчитывает количество пробелов в строке.
🎯 Решение:
```js
function countSpaces(str) {
  return str.split(' ').length - 1;
}

console.log(countSpaces('hello world how are you')); // 4
```
Объяснение: Мы разделяем строку по пробелам, а затем возвращаем количество полученных частей минус 1, чтобы посчитать пробелы.
---
5️⃣ Проверка, является ли строка палиндромом
⌛ Задача: Напишите функцию, которая проверяет, является ли строка палиндромом (т.е. читается одинаково слева направо и справа налево).
🎯 Решение:
```js
function isPalindrome(str) {
  return str === str.split('').reverse().join('');
}

console.log(isPalindrome('madam')); // true
console.log(isPalindrome('hello')); // false
```
Объяснение: Мы инвертируем строку и сравниваем её с оригиналом.
---
6️⃣ Конкатенация двух строк
⌛ Задача: Напишите функцию, которая принимает две строки и объединяет их в одну.
🎯 Решение:
```js
function concatStrings(str1, str2) {
  return str1 + str2;
}

console.log(concatStrings('hello', 'world')); // 'helloworld'
```
Объяснение: Мы используем оператор `+` для конкатенации строк.
---
7️⃣ Нахождение суммы чисел в массиве
⌛ Задача: Напишите функцию, которая находит сумму всех чисел в массиве.
🎯 Решение:
```js
function sumArray(arr) {
  return arr.reduce((acc, num) => acc + num, 0);
}

console.log(sumArray([1, 2, 3, 4])); // 10
```
Объяснение: Мы используем метод `reduce`, чтобы пройтись по массиву и суммировать все элементы.
---
8️⃣ Возведение числа в степень
⌛ Задача: Напишите функцию, которая возводит число в степень.
🎯 Решение:
```js
function power(base, exponent) {
  return Math.pow(base, exponent);
}

console.log(power(2, 3)); // 8
```
Объяснение: Мы используем встроенную функцию `Math.pow`, чтобы возвести число в степень.
---
9️⃣ Преобразование строки в верхний регистр
⌛ Задача: Напишите функцию, которая преобразует строку в верхний регистр.
🎯 Решение:
```js
function toUpperCase(str) {
  return str.toUpperCase();
}

console.log(toUpperCase('hello')); // 'HELLO'
```
Объяснение: Метод `toUpperCase` возвращает строку в верхнем регистре.
---
🔟 Нахождение длины строки
⌛ Задача: Напишите функцию, которая находит длину строки.
🎯 Решение:
```js
function stringLength(str) {
  return str.length;
}

console.log(stringLength('hello')); // 5
```
Объяснение: Свойство `length` возвращает количество символов в строке.
--------------------------------------------------------------------------------------------- 
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& 
---------------------
⋙ ❍ Динамическое программирование:
---
Динамическое программирование (ДП) — это метод решения задач, которые можно разделить на подзадачи, решения которых могут быть использованы для решения исходной задачи. В этом подходе важно запоминать уже решенные подзадачи, чтобы избежать повторных вычислений.
1. ⌛ Задача: Задача о рюкзаке (0/1)
Условие:
Дано множество предметов, каждый из которых имеет вес и стоимость. Нужно выбрать предметы таким образом, чтобы их суммарная стоимость была максимальной, а общий вес не превышал заданной вместимости рюкзака.
🎯 Решение:
```javascript
function knapsack(weights, values, capacity) {
  const n = weights.length;
  const dp = Array(n + 1).fill().map(() => Array(capacity + 1).fill(0));

  for (let i = 1; i <= n; i++) {
    for (let w = 1; w <= capacity; w++) {
      if (weights[i - 1] <= w) {
        dp[i][w] = Math.max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]);
      } else {
        dp[i][w] = dp[i - 1][w];
      }
    }
  }

  return dp[n][capacity];
}

const weights = [2, 3, 4, 5];
const values = [3, 4, 5, 6];
const capacity = 5;
console.log(knapsack(weights, values, capacity));  // 7
```
Объяснение:
Используется двумерный массив `dp`, где `dp[i][w]` — это максимальная стоимость, которую можно получить с первым `i` предметом и рюкзаком вместимости `w`. Мы итеративно заполняем этот массив, выбирая либо не включать предмет в рюкзак, либо включить его.
---
2. ⌛ Задача: Поиск длины наибольшей общей подпоследовательности (LCS)
Условие:
Даны две строки. Нужно найти длину наибольшей общей подпоследовательности (LCS).
🎯 Решение:
```javascript
function lcs(str1, str2) {
  const m = str1.length;
  const n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  return dp[m][n];
}

const str1 = "AGGTAB";
const str2 = "GXTXAYB";
console.log(lcs(str1, str2));  // 4
```
Объяснение:
Мы создаем двумерный массив `dp`, где `dp[i][j]` хранит длину LCS для первых `i` символов первой строки и первых `j` символов второй строки. Если символы строк совпадают, увеличиваем значение на 1, иначе берем максимальное значение из соседних ячеек.
---
3. ⌛ Задача: Задача о числе способов разложения числа (Проблема разбиения)
Условие:
Найти количество способов разложить число `n` на сумму чисел, используя числа от 1 до `n`.
🎯 Решение:
```javascript
function countPartitions(n) {
  const dp = Array(n + 1).fill(0);
  dp[0] = 1;  // Есть один способ разложить 0 (пустое разбиение)

  for (let i = 1; i <= n; i++) {
    for (let j = i; j <= n; j++) {
      dp[j] += dp[j - i];
    }
  }

  return dp[n];
}

const n = 5;
console.log(countPartitions(n));  // 7
```
Объяснение:
Используем динамическое программирование для подсчета способов разложения числа. Мы начинаем с разбиения 0 и добавляем все возможные числа от 1 до `n`.
---
4. ⌛ Задача: Числа Фибоначчи
Условие:
Найти `n`-е число Фибоначчи.
🎯 Решение:
```javascript
function fibonacci(n) {
  const dp = Array(n + 1).fill(0);
  dp[1] = 1;

  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[n];
}

console.log(fibonacci(10));  // 55
```
Объяснение:
Числа Фибоначчи можно вычислить, используя предыдущие два числа, что и делает этот алгоритм. Мы создаем массив для хранения всех чисел до `n`, начиная с 0 и 1.
---
5. ⌛ Задача: Задача о минимальной стоимости пути в сетке
Условие:
Дана сетка (матрица), где каждая ячейка содержит стоимость перемещения через нее. Нужно найти минимальную стоимость пути от верхнего левого угла до правого нижнего, перемещаясь только вниз или вправо.
🎯 Решение:
```javascript
function minPathSum(grid) {
  const m = grid.length;
  const n = grid[0].length;
  const dp = Array(m).fill().map(() => Array(n).fill(0));

  dp[0][0] = grid[0][0];

  for (let i = 1; i < m; i++) {
    dp[i][0] = dp[i - 1][0] + grid[i][0];
  }

  for (let j = 1; j < n; j++) {
    dp[0][j] = dp[0][j - 1] + grid[0][j];
  }

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
    }
  }

  return dp[m - 1][n - 1];
}

const grid = [
  [1, 3, 1],
  [1, 5, 1],
  [4, 2, 1]
];
console.log(minPathSum(grid));  // 7
```
Объяснение:
Для каждой ячейки мы находим минимальную стоимость пути, добавляя стоимость текущей ячейки к минимальной стоимости из соседей (слева или сверху).
---
6. ⌛ Задача: Задача о лестнице
Условие:
Нужно найти количество способов подняться на вершину лестницы, если можно делать шаги по 1 или 2 ступеньки.
🎯 Решение:
```javascript
function climbStairs(n) {
  const dp = Array(n + 1).fill(0);
  dp[0] = 1;
  dp[1] = 1;

  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[n];
}

console.log(climbStairs(5));  // 8
```
Объяснение:
Для каждой ступеньки мы находим количество способов, используя предыдущие две ступеньки (по аналогии с числами Фибоначчи).
---
7. ⌛ Задача: Декартовы произведения (Перестановки с повторениями)
Условие:
Найти все перестановки элементов множества с возможными повторениями.
🎯 Решение:
```javascript
function permute(nums) {
  const res = [];
  const dp = (current) => {
    if (current.length === nums.length) {
      res.push([...current]);
      return;
    }

    for (let i = 0; i < nums.length; i++) {
      current.push(nums[i]);
      dp(current);
      current.pop();
    }
  };
  dp([]);
  return res;
}

console.log(permute([1, 2, 3]));
```
Объяснение:
Используем рекурсивный подход для генерации всех возможных перестановок с помощью динамического программирования.
---
8. ⌛ Задача: Разбиение числа на сумму чисел
Условие:
Найти количество способов разложить число `n` на сумму чисел от 1 до `n`.
🎯 Решение:
```javascript
function partitionNumber(n) {
  const dp = Array(n + 1).fill(0);
  dp[0] = 1;

  for (let i = 1; i <= n; i++) {
    for (let j = i; j <= n; j++) {
      dp[j] += dp[j - i];
    }
  }

  return dp[n];
}

console.log(partitionNumber(5));  // 7
```
Объяснение:
Задача заключается в том, чтобы найти количество разбиений числа `n`. Для этого создаем массив `dp`, где `dp[i]` хранит количество способов разбиения числа `i`. Внешний цикл пробегает по числам от 1 до `n`, а внутренний — по возможным значениям для разбиений.
---
9. ⌛ Задача: Наибольшая возрастающая подпоследовательность
Дана последовательность чисел. Необходимо найти длину наибольшей возрастающей подпоследовательности.
🎯 Решение:
```javascript
function longestIncreasingSubsequence(nums) {
  if (nums.length === 0) return 0;

  const dp = Array(nums.length).fill(1);

  for (let i = 1; i < nums.length; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }

  return Math.max(...dp);
}

console.log(longestIncreasingSubsequence([10, 9, 2, 5, 3, 7, 101, 18]));  // 4
```
Объяснение:
Мы используем динамическое программирование для решения задачи. В массиве `dp` хранится длина наибольшей возрастающей подпоследовательности, заканчивающейся на каждом элементе. Если элемент текущей последовательности больше предыдущего, то длина возрастающей подпоследовательности обновляется.
---
10. ⌛ Задача: Минимальная сумма пути в треугольнике
Условие:
Дан треугольник чисел, нужно найти путь с минимальной суммой, начиная с вершины и двигаясь к нижнему ряду, только перемещаясь по соседним числам.
🎯 Решение:
```javascript
function minimumTotal(triangle) {
  const n = triangle.length;
  const dp = Array(n).fill(0);

  // Идем с последнего ряда треугольника
  for (let row = n - 1; row >= 0; row--) {
    for (let col = 0; col <= row; col++) {
      if (row === n - 1) {
        dp[col] = triangle[row][col];
      } else {
        dp[col] = Math.min(dp[col], dp[col + 1]) + triangle[row][col];
      }
    }
  }

  return dp[0];
}

const triangle = [
  [2],
  [3, 4],
  [6, 5, 7],
  [4, 1, 8, 3]
];

console.log(minimumTotal(triangle));  // 11
```
Объяснение:
Мы начинаем с последнего ряда треугольника и двигаемся к первому. Для каждой ячейки вычисляем минимальную сумму, добавляя минимальную сумму из соседних элементов на следующем уровне. Таким образом, получаем минимальную сумму пути, начиная с вершины треугольника.
Эти задачи показывают разнообразие применения динамического программирования и решают различные задачи с использованием подхода оптимизации и запоминания подзадач.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& 
---------------------
⋙ ❍ Принципы построения алгоритмов:
---
Принципы построения алгоритмов играют ключевую роль в разработке эффективных и понятных решений для различных задач.
1. ⌛ Задача: Проверка на палиндром
Условие:
Напишите функцию, которая проверяет, является ли строка палиндромом.
🎯 Решение:
```javascript
function isPalindrome(str) {
  const cleanedStr = str.replace(/\W/g, '').toLowerCase();  // Убираем все неалфавитные символы и приводим к нижнему регистру
  const reversedStr = cleanedStr.split('').reverse().join('');
  return cleanedStr === reversedStr;
}

console.log(isPalindrome("A man, a plan, a canal, Panama"));  // true
```
Объяснение:
Для проверки на палиндром мы приводим строку к нижнему регистру и удаляем все неалфавитные символы с помощью регулярных выражений. Затем сравниваем строку с её перевёрнутой версией.
---
2. ⌛ Задача: Сортировка пузырьком
Условие:
Реализуйте алгоритм сортировки пузырьком.
🎯 Решение:
```javascript
function bubbleSort(arr) {
  const n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];  // Меняем местами элементы
      }
    }
  }
  return arr;
}

console.log(bubbleSort([5, 2, 9, 1, 5, 6]));  // [1, 2, 5, 5, 6, 9]
```
Объяснение:
Алгоритм сортировки пузырьком состоит в том, что на каждом проходе по массиву мы сравниваем соседние элементы и меняем их местами, если они идут в неправильном порядке. Процесс повторяется, пока не будет достигнут отсортированный массив.
---
3. ⌛ Задача: Нахождение максимального элемента в массиве
Условие:
Напишите функцию, которая находит максимальное значение в массиве.
🎯 Решение:
```javascript
function findMax(arr) {
  let max = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }
  return max;
}

console.log(findMax([1, 5, 3, 9, 2]));  // 9
```
Объяснение:
Мы инициализируем переменную `max` значением первого элемента массива и далее поочередно сравниваем его с остальными элементами массива, обновляя значение `max`, если текущий элемент больше.
---
4. ⌛ Задача: Нахождение факториала числа
Условие:
Напишите функцию для нахождения факториала числа.
🎯 Решение:
```javascript
function factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  }
  return n * factorial(n - 1);  // Рекурсивный вызов
}

console.log(factorial(5));  // 120
```
Объяснение:
Используем рекурсию для нахождения факториала числа. В каждом рекурсивном вызове уменьшаем значение на 1, пока не достигнем базового случая (0 или 1).
---
5. ⌛ Задача: Поиск в массиве с использованием бинарного поиска
Условие:
Напишите функцию для поиска элемента в отсортированном массиве с использованием бинарного поиска.
🎯 Решение:
```javascript
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;  // Элемент не найден
}

console.log(binarySearch([1, 2, 3, 4, 5], 3));  // 2
```
Объяснение:
Бинарный поиск работает на отсортированных массивах. Мы начинаем с поиска среднего элемента и сравниваем его с искомым значением. В зависимости от результата поиска мы сужаем область поиска, повторяя процесс.
---
6. ⌛ Задача: Чтение строк и подсчёт гласных
Условие:
Напишите функцию, которая подсчитывает количество гласных букв в строке.
🎯 Решение:
```javascript
function countVowels(str) {
  const vowels = 'aeiouAEIOU';
  let count = 0;

  for (let char of str) {
    if (vowels.includes(char)) {
      count++;
    }
  }

  return count;
}

console.log(countVowels("Hello World!"));  // 3
```
Объяснение:
Мы проходим по всем символам строки и проверяем, является ли символ гласной (включен ли он в строку `vowels`). Если да, увеличиваем счётчик.
---
7. ⌛ Задача: Сумма всех элементов в массиве
Условие:
Напишите функцию, которая находит сумму всех элементов в массиве.
🎯 Решение:
```javascript
function sumArray(arr) {
  let sum = 0;
  for (let num of arr) {
    sum += num;
  }
  return sum;
}

console.log(sumArray([1, 2, 3, 4, 5]));  // 15
```
Объяснение:
Проходим по всем элементам массива и добавляем каждый элемент к переменной `sum`, которая в итоге и будет содержать сумму всех чисел.
---
8. ⌛ Задача: Обратный порядок элементов в массиве
Условие:
Напишите функцию, которая возвращает массив в обратном порядке.
🎯 Решение:
```javascript
function reverseArray(arr) {
  const reversedArr = [];
  for (let i = arr.length - 1; i >= 0; i--) {
    reversedArr.push(arr[i]);
  }
  return reversedArr;
}

console.log(reverseArray([1, 2, 3, 4, 5]));  // [5, 4, 3, 2, 1]
```
Объяснение:
Создаём новый массив `reversedArr` и заполняем его элементами исходного массива в обратном порядке, начиная с последнего элемента.
---
9. ⌛ Задача: Генерация чисел Фибоначчи
Условие:
Напишите функцию для генерации последовательности чисел Фибоначчи до `n`-го числа.
🎯 Решение:
```javascript
function fibonacci(n) {
  const fib = [0, 1];

  for (let i = 2; i < n; i++) {
    fib[i] = fib[i - 1] + fib[i - 2];
  }

  return fib;
}

console.log(fibonacci(6));  // [0, 1, 1, 2, 3, 5]
```
Объяснение:
В начале создаём массив с двумя первыми числами Фибоначчи (0 и 1), а затем добавляем новые числа, суммируя два предыдущих.
---
10. ⌛ Задача: Проверка на четность числа
Условие:
Напишите функцию, которая проверяет, является ли число четным.
🎯 Решение:
```javascript
function isEven(num) {
  return num % 2 === 0;
}

console.log(isEven(4));  // true
console.log(isEven(7));  // false
```
Объяснение:
Для проверки на чётность достаточно проверить, даёт ли деление числа на 2 остаток 0. Если остаток 0, значит число чётное.
Эти задачи демонстрируют различные принципы построения алгоритмов, такие как: использование рекурсии, обход коллекций, сортировка, проверка условий и работы с данными.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& 
---------------------
⋙ ❍ Задача «Простой калькулятор»:
---
⌛ Задача 1: Сложение двух чисел
Условие:
Напишите функцию, которая принимает два числа и возвращает их сумму.
🎯 Решение:
```javascript
function add(a, b) {
  return a + b;
}

console.log(add(5, 3));  // 8
```
Объяснение:
Это самая базовая операция сложения. Функция принимает два числа и возвращает их сумму.
---
⌛ Задача 2: Вычитание двух чисел
Условие:
Напишите функцию, которая принимает два числа и возвращает их разницу.
🎯 Решение:
```javascript
function subtract(a, b) {
  return a - b;
}

console.log(subtract(5, 3));  // 2
```
Объяснение:
Здесь мы используем стандартную операцию вычитания, чтобы найти разницу между двумя числами.
---
⌛ Задача 3: Умножение двух чисел
Условие:
Напишите функцию, которая принимает два числа и возвращает их произведение.
🎯 Решение:
```javascript
function multiply(a, b) {
  return a * b;
}

console.log(multiply(5, 3));  // 15
```
Объяснение:
Здесь мы умножаем два числа и возвращаем результат.
---
⌛ Задача 4: Деление двух чисел
Условие:
Напишите функцию, которая принимает два числа и возвращает результат их деления. Учтите, что деление на 0 не должно происходить.
🎯 Решение:
```javascript
function divide(a, b) {
  if (b === 0) {
    return 'Error: Division by zero';
  }
  return a / b;
}

console.log(divide(6, 3));  // 2
console.log(divide(5, 0));  // 'Error: Division by zero'
```
Объяснение:
Мы проверяем, если делитель равен 0, и в таком случае возвращаем ошибку. Если деление возможно, возвращаем результат.
---
⌛ Задача 5: Возведение в степень
Условие:
Напишите функцию, которая принимает два числа: основание и степень, и возвращает результат возведения основания в степень.
🎯 Решение:
```javascript
function power(base, exponent) {
  return Math.pow(base, exponent);
}

console.log(power(2, 3));  // 8
```
Объяснение:
Используем стандартную функцию `Math.pow`, чтобы возвести число в заданную степень.
---
⌛ Задача 6: Калькулятор с несколькими операциями
Условие:
Напишите функцию, которая принимает три аргумента: два числа и операцию, и возвращает результат операции (сложение, вычитание, умножение или деление).
🎯 Решение:
```javascript
function calculator(a, b, operation) {
  switch (operation) {
    case 'add':
      return a + b;
    case 'subtract':
      return a - b;
    case 'multiply':
      return a * b;
    case 'divide':
      if (b === 0) {
        return 'Error: Division by zero';
      }
      return a / b;
    default:
      return 'Invalid operation';
  }
}

console.log(calculator(5, 3, 'add'));       // 8
console.log(calculator(5, 3, 'subtract'));  // 2
console.log(calculator(5, 3, 'multiply'));  // 15
console.log(calculator(5, 0, 'divide'));    // 'Error: Division by zero'
```
Объяснение:
Мы используем `switch` для выбора операции на основе аргумента `operation`. Это позволяет легко расширить калькулятор, добавляя новые операции.
---
⌛ Задача 7: Подсчёт факториала
Условие:
Напишите функцию, которая принимает число и возвращает его факториал.
🎯 Решение:
```javascript
function factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  }
  let result = 1;
  for (let i = 2; i <= n; i++) {
    result *= i;
  }
  return result;
}

console.log(factorial(5));  // 120
```
Объяснение:
Мы используем цикл, чтобы перемножить все числа от 1 до `n`, получая факториал числа.
---
⌛ Задача 8: Проверка на простое число
Условие:
Напишите функцию, которая проверяет, является ли число простым.
🎯 Решение:
```javascript
function isPrime(n) {
  if (n <= 1) return false;
  for (let i = 2; i <= Math.sqrt(n); i++) {
    if (n % i === 0) return false;
  }
  return true;
}

console.log(isPrime(7));  // true
console.log(isPrime(10)); // false
```
Объяснение:
Для проверки простоты числа мы делим его на все числа от 2 до квадратного корня из числа. Если ни одно из делений не даёт целочисленного результата, число простое.
---
⌛ Задача 9: Нахождение квадратного корня
Условие:
Напишите функцию, которая принимает число и возвращает его квадратный корень.
🎯 Решение:
```javascript
function squareRoot(n) {
  if (n < 0) {
    return 'Error: Negative number';
  }
  return Math.sqrt(n);
}

console.log(squareRoot(9));  // 3
console.log(squareRoot(-9)); // 'Error: Negative number'
```
Объяснение:
Используем функцию `Math.sqrt` для нахождения квадратного корня. Также добавлена проверка на отрицательные числа, так как для них квадратный корень не существует в области вещественных чисел.
---
⌛ Задача 10: Ввод данных и выполнение операции через prompt
Условие:
Напишите калькулятор, который принимает два числа и операцию через `prompt` и выводит результат.
🎯 Решение:
```javascript
function simpleCalculator() {
  const a = parseFloat(prompt('Enter the first number:'));
  const b = parseFloat(prompt('Enter the second number:'));
  const operation = prompt('Enter the operation (add, subtract, multiply, divide):');

  switch (operation) {
    case 'add':
      alert(a + b);
      break;
    case 'subtract':
      alert(a - b);
      break;
    case 'multiply':
      alert(a * b);
      break;
    case 'divide':
      if (b === 0) {
        alert('Error: Division by zero');
      } else {
        alert(a / b);
      }
      break;
    default:
      alert('Invalid operation');
  }
}

simpleCalculator();
```
Объяснение:
В этой задаче мы используем `prompt` для ввода данных и `alert` для вывода результата. Код взаимодействует с пользователем через диалоговые окна.
Эти задачи покрывают основные операции калькулятора, такие как сложение, вычитание, умножение, деление и несколько более сложных задач, таких как факториал, проверка на простоту и квадратный корень.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& 

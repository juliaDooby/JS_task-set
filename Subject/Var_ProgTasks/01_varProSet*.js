CHECK DUBLES!!!
Эти задачи помогут вам потренировать базовые операции с числами, строками и массивами, улучшив навыки работы с последовательными алгоритмами в JavaScript.
1️⃣ Проверка наличия числа в массиве
⌛ Задача: Напишите функцию, которая проверяет, есть ли число в массиве.
🎯 Решение:
```js
function contains(arr, num) {
  return arr.includes(num);
}

console.log(contains([1, 2, 3, 4], 3)); // true
console.log(contains([1, 2, 3, 4], 5)); // false
```
Объяснение: Мы используем метод `includes`, чтобы проверить наличие элемента в массиве.
---
2️⃣ Нахождение минимального числа
⌛ Задача: Напишите функцию, которая находит минимальное число из массива.
🎯 Решение:
```js
function findMin(arr) {
  return Math.min(...arr);
}

console.log(findMin([10, 2, 33, 4])); // 2
```
Объяснение: Для нахождения минимального числа используем встроенную функцию `Math.min` с распаковкой массива с помощью оператора `...`.
---
3️⃣ Проверка, является ли число положительным
⌛ Задача: Напишите функцию, которая проверяет, является ли число положительным.
🎯 Решение:
```js
function isPositive(num) {
  return num > 0;
}

console.log(isPositive(5)); // true
console.log(isPositive(-3)); // false
```
Объяснение: Мы проверяем, больше ли число нуля. Если да, то оно положительное.
---
4️⃣ Подсчет количества пробелов в строке
⌛ Задача: Напишите функцию, которая подсчитывает количество пробелов в строке.
🎯 Решение:
```js
function countSpaces(str) {
  return str.split(' ').length - 1;
}

console.log(countSpaces('hello world how are you')); // 4
```
Объяснение: Мы разделяем строку по пробелам, а затем возвращаем количество полученных частей минус 1, чтобы посчитать пробелы.
---
5️⃣ Проверка, является ли строка палиндромом
⌛ Задача: Напишите функцию, которая проверяет, является ли строка палиндромом (т.е. читается одинаково слева направо и справа налево).
🎯 Решение:
```js
function isPalindrome(str) {
  return str === str.split('').reverse().join('');
}

console.log(isPalindrome('madam')); // true
console.log(isPalindrome('hello')); // false
```
Объяснение: Мы инвертируем строку и сравниваем её с оригиналом.
---
6️⃣ Конкатенация двух строк
⌛ Задача: Напишите функцию, которая принимает две строки и объединяет их в одну.
🎯 Решение:
```js
function concatStrings(str1, str2) {
  return str1 + str2;
}

console.log(concatStrings('hello', 'world')); // 'helloworld'
```
Объяснение: Мы используем оператор `+` для конкатенации строк.
---
7️⃣ Нахождение суммы чисел в массиве
⌛ Задача: Напишите функцию, которая находит сумму всех чисел в массиве.
🎯 Решение:
```js
function sumArray(arr) {
  return arr.reduce((acc, num) => acc + num, 0);
}

console.log(sumArray([1, 2, 3, 4])); // 10
```
Объяснение: Мы используем метод `reduce`, чтобы пройтись по массиву и суммировать все элементы.
---
8️⃣ Возведение числа в степень
⌛ Задача: Напишите функцию, которая возводит число в степень.
🎯 Решение:
```js
function power(base, exponent) {
  return Math.pow(base, exponent);
}

console.log(power(2, 3)); // 8
```
Объяснение: Мы используем встроенную функцию `Math.pow`, чтобы возвести число в степень.
---
9️⃣ Преобразование строки в верхний регистр
⌛ Задача: Напишите функцию, которая преобразует строку в верхний регистр.
🎯 Решение:
```js
function toUpperCase(str) {
  return str.toUpperCase();
}

console.log(toUpperCase('hello')); // 'HELLO'
```
Объяснение: Метод `toUpperCase` возвращает строку в верхнем регистре.
---
🔟 Нахождение длины строки
⌛ Задача: Напишите функцию, которая находит длину строки.
🎯 Решение:
```js
function stringLength(str) {
  return str.length;
}

console.log(stringLength('hello')); // 5
```
Объяснение: Свойство `length` возвращает количество символов в строке.
--------------------------------------------------------------------------------------------- 
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& 
---------------------
⋙ ❍ Динамическое программирование:
---
Динамическое программирование (ДП) — это метод решения задач, которые можно разделить на подзадачи, решения которых могут быть использованы для решения исходной задачи. В этом подходе важно запоминать уже решенные подзадачи, чтобы избежать повторных вычислений.
1. ⌛ Задача: Задача о рюкзаке (0/1)
Условие:
Дано множество предметов, каждый из которых имеет вес и стоимость. Нужно выбрать предметы таким образом, чтобы их суммарная стоимость была максимальной, а общий вес не превышал заданной вместимости рюкзака.
🎯 Решение:
```javascript
function knapsack(weights, values, capacity) {
  const n = weights.length;
  const dp = Array(n + 1).fill().map(() => Array(capacity + 1).fill(0));

  for (let i = 1; i <= n; i++) {
    for (let w = 1; w <= capacity; w++) {
      if (weights[i - 1] <= w) {
        dp[i][w] = Math.max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]);
      } else {
        dp[i][w] = dp[i - 1][w];
      }
    }
  }

  return dp[n][capacity];
}

const weights = [2, 3, 4, 5];
const values = [3, 4, 5, 6];
const capacity = 5;
console.log(knapsack(weights, values, capacity));  // 7
```
Объяснение:
Используется двумерный массив `dp`, где `dp[i][w]` — это максимальная стоимость, которую можно получить с первым `i` предметом и рюкзаком вместимости `w`. Мы итеративно заполняем этот массив, выбирая либо не включать предмет в рюкзак, либо включить его.
---
2. ⌛ Задача: Поиск длины наибольшей общей подпоследовательности (LCS)
Условие:
Даны две строки. Нужно найти длину наибольшей общей подпоследовательности (LCS).
🎯 Решение:
```javascript
function lcs(str1, str2) {
  const m = str1.length;
  const n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  return dp[m][n];
}

const str1 = "AGGTAB";
const str2 = "GXTXAYB";
console.log(lcs(str1, str2));  // 4
```
Объяснение:
Мы создаем двумерный массив `dp`, где `dp[i][j]` хранит длину LCS для первых `i` символов первой строки и первых `j` символов второй строки. Если символы строк совпадают, увеличиваем значение на 1, иначе берем максимальное значение из соседних ячеек.
---
3. ⌛ Задача: Задача о числе способов разложения числа (Проблема разбиения)
Условие:
Найти количество способов разложить число `n` на сумму чисел, используя числа от 1 до `n`.
🎯 Решение:
```javascript
function countPartitions(n) {
  const dp = Array(n + 1).fill(0);
  dp[0] = 1;  // Есть один способ разложить 0 (пустое разбиение)

  for (let i = 1; i <= n; i++) {
    for (let j = i; j <= n; j++) {
      dp[j] += dp[j - i];
    }
  }

  return dp[n];
}

const n = 5;
console.log(countPartitions(n));  // 7
```
Объяснение:
Используем динамическое программирование для подсчета способов разложения числа. Мы начинаем с разбиения 0 и добавляем все возможные числа от 1 до `n`.
---
4. ⌛ Задача: Числа Фибоначчи
Условие:
Найти `n`-е число Фибоначчи.
🎯 Решение:
```javascript
function fibonacci(n) {
  const dp = Array(n + 1).fill(0);
  dp[1] = 1;

  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[n];
}

console.log(fibonacci(10));  // 55
```
Объяснение:
Числа Фибоначчи можно вычислить, используя предыдущие два числа, что и делает этот алгоритм. Мы создаем массив для хранения всех чисел до `n`, начиная с 0 и 1.
---
5. ⌛ Задача: Задача о минимальной стоимости пути в сетке
Условие:
Дана сетка (матрица), где каждая ячейка содержит стоимость перемещения через нее. Нужно найти минимальную стоимость пути от верхнего левого угла до правого нижнего, перемещаясь только вниз или вправо.
🎯 Решение:
```javascript
function minPathSum(grid) {
  const m = grid.length;
  const n = grid[0].length;
  const dp = Array(m).fill().map(() => Array(n).fill(0));

  dp[0][0] = grid[0][0];

  for (let i = 1; i < m; i++) {
    dp[i][0] = dp[i - 1][0] + grid[i][0];
  }

  for (let j = 1; j < n; j++) {
    dp[0][j] = dp[0][j - 1] + grid[0][j];
  }

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
    }
  }

  return dp[m - 1][n - 1];
}

const grid = [
  [1, 3, 1],
  [1, 5, 1],
  [4, 2, 1]
];
console.log(minPathSum(grid));  // 7
```
Объяснение:
Для каждой ячейки мы находим минимальную стоимость пути, добавляя стоимость текущей ячейки к минимальной стоимости из соседей (слева или сверху).
---
6. ⌛ Задача: Задача о лестнице
Условие:
Нужно найти количество способов подняться на вершину лестницы, если можно делать шаги по 1 или 2 ступеньки.
🎯 Решение:
```javascript
function climbStairs(n) {
  const dp = Array(n + 1).fill(0);
  dp[0] = 1;
  dp[1] = 1;

  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[n];
}

console.log(climbStairs(5));  // 8
```
Объяснение:
Для каждой ступеньки мы находим количество способов, используя предыдущие две ступеньки (по аналогии с числами Фибоначчи).
---
7. ⌛ Задача: Декартовы произведения (Перестановки с повторениями)
Условие:
Найти все перестановки элементов множества с возможными повторениями.
🎯 Решение:
```javascript
function permute(nums) {
  const res = [];
  const dp = (current) => {
    if (current.length === nums.length) {
      res.push([...current]);
      return;
    }

    for (let i = 0; i < nums.length; i++) {
      current.push(nums[i]);
      dp(current);
      current.pop();
    }
  };
  dp([]);
  return res;
}

console.log(permute([1, 2, 3]));
```
Объяснение:
Используем рекурсивный подход для генерации всех возможных перестановок с помощью динамического программирования.
---
8. ⌛ Задача: Разбиение числа на сумму чисел
Условие:
Найти количество способов разложить число `n` на сумму чисел от 1 до `n`.
🎯 Решение:
```javascript
function partitionNumber(n) {
  const dp = Array(n + 1).fill(0);
  dp[0] = 1;

  for (let i = 1; i <= n; i++) {
    for (let j = i; j <= n; j++) {
      dp[j] += dp[j - i];
    }
  }

  return dp[n];
}

console.log(partitionNumber(5));  // 7
```
Объяснение:
Задача заключается в том, чтобы найти количество разбиений числа `n`. Для этого создаем массив `dp`, где `dp[i]` хранит количество способов разбиения числа `i`. Внешний цикл пробегает по числам от 1 до `n`, а внутренний — по возможным значениям для разбиений.
---
9. ⌛ Задача: Наибольшая возрастающая подпоследовательность
Дана последовательность чисел. Необходимо найти длину наибольшей возрастающей подпоследовательности.
🎯 Решение:
```javascript
function longestIncreasingSubsequence(nums) {
  if (nums.length === 0) return 0;

  const dp = Array(nums.length).fill(1);

  for (let i = 1; i < nums.length; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }

  return Math.max(...dp);
}

console.log(longestIncreasingSubsequence([10, 9, 2, 5, 3, 7, 101, 18]));  // 4
```
Объяснение:
Мы используем динамическое программирование для решения задачи. В массиве `dp` хранится длина наибольшей возрастающей подпоследовательности, заканчивающейся на каждом элементе. Если элемент текущей последовательности больше предыдущего, то длина возрастающей подпоследовательности обновляется.
---
10. ⌛ Задача: Минимальная сумма пути в треугольнике
Условие:
Дан треугольник чисел, нужно найти путь с минимальной суммой, начиная с вершины и двигаясь к нижнему ряду, только перемещаясь по соседним числам.
🎯 Решение:
```javascript
function minimumTotal(triangle) {
  const n = triangle.length;
  const dp = Array(n).fill(0);

  // Идем с последнего ряда треугольника
  for (let row = n - 1; row >= 0; row--) {
    for (let col = 0; col <= row; col++) {
      if (row === n - 1) {
        dp[col] = triangle[row][col];
      } else {
        dp[col] = Math.min(dp[col], dp[col + 1]) + triangle[row][col];
      }
    }
  }

  return dp[0];
}

const triangle = [
  [2],
  [3, 4],
  [6, 5, 7],
  [4, 1, 8, 3]
];

console.log(minimumTotal(triangle));  // 11
```
Объяснение:
Мы начинаем с последнего ряда треугольника и двигаемся к первому. Для каждой ячейки вычисляем минимальную сумму, добавляя минимальную сумму из соседних элементов на следующем уровне. Таким образом, получаем минимальную сумму пути, начиная с вершины треугольника.
Эти задачи показывают разнообразие применения динамического программирования и решают различные задачи с использованием подхода оптимизации и запоминания подзадач.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& 
---------------------
⋙ ❍ Принципы построения алгоритмов:
---
Принципы построения алгоритмов играют ключевую роль в разработке эффективных и понятных решений для различных задач.
1. ⌛ Задача: Проверка на палиндром
Условие:
Напишите функцию, которая проверяет, является ли строка палиндромом.
🎯 Решение:
```javascript
function isPalindrome(str) {
  const cleanedStr = str.replace(/\W/g, '').toLowerCase();  // Убираем все неалфавитные символы и приводим к нижнему регистру
  const reversedStr = cleanedStr.split('').reverse().join('');
  return cleanedStr === reversedStr;
}

console.log(isPalindrome("A man, a plan, a canal, Panama"));  // true
```
Объяснение:
Для проверки на палиндром мы приводим строку к нижнему регистру и удаляем все неалфавитные символы с помощью регулярных выражений. Затем сравниваем строку с её перевёрнутой версией.
---
2. ⌛ Задача: Сортировка пузырьком
Условие:
Реализуйте алгоритм сортировки пузырьком.
🎯 Решение:
```javascript
function bubbleSort(arr) {
  const n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];  // Меняем местами элементы
      }
    }
  }
  return arr;
}

console.log(bubbleSort([5, 2, 9, 1, 5, 6]));  // [1, 2, 5, 5, 6, 9]
```
Объяснение:
Алгоритм сортировки пузырьком состоит в том, что на каждом проходе по массиву мы сравниваем соседние элементы и меняем их местами, если они идут в неправильном порядке. Процесс повторяется, пока не будет достигнут отсортированный массив.
---
3. ⌛ Задача: Нахождение максимального элемента в массиве
Условие:
Напишите функцию, которая находит максимальное значение в массиве.
🎯 Решение:
```javascript
function findMax(arr) {
  let max = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }
  return max;
}

console.log(findMax([1, 5, 3, 9, 2]));  // 9
```
Объяснение:
Мы инициализируем переменную `max` значением первого элемента массива и далее поочередно сравниваем его с остальными элементами массива, обновляя значение `max`, если текущий элемент больше.
---
4. ⌛ Задача: Нахождение факториала числа
Условие:
Напишите функцию для нахождения факториала числа.
🎯 Решение:
```javascript
function factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  }
  return n * factorial(n - 1);  // Рекурсивный вызов
}

console.log(factorial(5));  // 120
```
Объяснение:
Используем рекурсию для нахождения факториала числа. В каждом рекурсивном вызове уменьшаем значение на 1, пока не достигнем базового случая (0 или 1).
---
5. ⌛ Задача: Поиск в массиве с использованием бинарного поиска
Условие:
Напишите функцию для поиска элемента в отсортированном массиве с использованием бинарного поиска.
🎯 Решение:
```javascript
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;  // Элемент не найден
}

console.log(binarySearch([1, 2, 3, 4, 5], 3));  // 2
```
Объяснение:
Бинарный поиск работает на отсортированных массивах. Мы начинаем с поиска среднего элемента и сравниваем его с искомым значением. В зависимости от результата поиска мы сужаем область поиска, повторяя процесс.
---
6. ⌛ Задача: Чтение строк и подсчёт гласных
Условие:
Напишите функцию, которая подсчитывает количество гласных букв в строке.
🎯 Решение:
```javascript
function countVowels(str) {
  const vowels = 'aeiouAEIOU';
  let count = 0;

  for (let char of str) {
    if (vowels.includes(char)) {
      count++;
    }
  }

  return count;
}

console.log(countVowels("Hello World!"));  // 3
```
Объяснение:
Мы проходим по всем символам строки и проверяем, является ли символ гласной (включен ли он в строку `vowels`). Если да, увеличиваем счётчик.
---
7. ⌛ Задача: Сумма всех элементов в массиве
Условие:
Напишите функцию, которая находит сумму всех элементов в массиве.
🎯 Решение:
```javascript
function sumArray(arr) {
  let sum = 0;
  for (let num of arr) {
    sum += num;
  }
  return sum;
}

console.log(sumArray([1, 2, 3, 4, 5]));  // 15
```
Объяснение:
Проходим по всем элементам массива и добавляем каждый элемент к переменной `sum`, которая в итоге и будет содержать сумму всех чисел.
---
8. ⌛ Задача: Обратный порядок элементов в массиве
Условие:
Напишите функцию, которая возвращает массив в обратном порядке.
🎯 Решение:
```javascript
function reverseArray(arr) {
  const reversedArr = [];
  for (let i = arr.length - 1; i >= 0; i--) {
    reversedArr.push(arr[i]);
  }
  return reversedArr;
}

console.log(reverseArray([1, 2, 3, 4, 5]));  // [5, 4, 3, 2, 1]
```
Объяснение:
Создаём новый массив `reversedArr` и заполняем его элементами исходного массива в обратном порядке, начиная с последнего элемента.
---
9. ⌛ Задача: Генерация чисел Фибоначчи
Условие:
Напишите функцию для генерации последовательности чисел Фибоначчи до `n`-го числа.
🎯 Решение:
```javascript
function fibonacci(n) {
  const fib = [0, 1];

  for (let i = 2; i < n; i++) {
    fib[i] = fib[i - 1] + fib[i - 2];
  }

  return fib;
}

console.log(fibonacci(6));  // [0, 1, 1, 2, 3, 5]
```
Объяснение:
В начале создаём массив с двумя первыми числами Фибоначчи (0 и 1), а затем добавляем новые числа, суммируя два предыдущих.
---
10. ⌛ Задача: Проверка на четность числа
Условие:
Напишите функцию, которая проверяет, является ли число четным.
🎯 Решение:
```javascript
function isEven(num) {
  return num % 2 === 0;
}

console.log(isEven(4));  // true
console.log(isEven(7));  // false
```
Объяснение:
Для проверки на чётность достаточно проверить, даёт ли деление числа на 2 остаток 0. Если остаток 0, значит число чётное.
Эти задачи демонстрируют различные принципы построения алгоритмов, такие как: использование рекурсии, обход коллекций, сортировка, проверка условий и работы с данными.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& 
---------------------
⋙ ❍ Задача «Размен 2»:
---
Задача «Размен 2» обычно относится к задачам динамического программирования, в которых нужно найти минимальное количество монет для размена определенной суммы с использованием набора монет определенных номиналов. В данном случае будет предложено 10 различных задач с решением на языке JavaScript, связанных с разменом.
1. ⌛ Задача: Минимальное количество монет для размена суммы
Условие:
Дан набор монет и сумма, нужно найти минимальное количество монет, с помощью которых можно разменять заданную сумму.
🎯 Решение:
```javascript
function minCoins(coins, amount) {
  const dp = Array(amount + 1).fill(Infinity);
  dp[0] = 0;

  for (let i = 1; i <= amount; i++) {
    for (let coin of coins) {
      if (i >= coin) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1);
      }
    }
  }

  return dp[amount] === Infinity ? -1 : dp[amount];
}

console.log(minCoins([1, 2, 5], 11));  // 3 (5 + 5 + 1)
```
Объяснение:
Массив `dp` используется для хранения минимального количества монет для размена суммы `i`. В каждом шаге проверяется, можно ли использовать монету для уменьшения текущей суммы.
---
2. ⌛ Задача: Размен суммы с заданными номиналами (ограничения на количество монет)
Условие:
Есть набор монет с ограниченным количеством каждой монеты. Нужно найти, возможно ли разменять сумму, используя не более заданного количества каждой монеты.
🎯 Решение:
```javascript
function minCoinsLimited(coins, limit, amount) {
  const dp = Array(amount + 1).fill(Infinity);
  dp[0] = 0;

  for (let i = 0; i < coins.length; i++) {
    for (let j = amount; j >= coins[i]; j--) {
      for (let k = 1; k <= limit[i] && k * coins[i] <= j; k++) {
        dp[j] = Math.min(dp[j], dp[j - k * coins[i]] + k);
      }
    }
  }

  return dp[amount] === Infinity ? -1 : dp[amount];
}

console.log(minCoinsLimited([1, 2, 5], [2, 2, 2], 11));  // 3
```
Объяснение:
Используем динамическое программирование с дополнительной проверкой на ограничение количества монет. Для каждой монеты проверяется, сколько раз её можно использовать для достижения заданной суммы.
---
3. ⌛ Задача: Размен суммы с использованием только монет одной валюты
Условие:
Есть только один номинал монет. Нужно найти минимальное количество монет для размена суммы.
🎯 Решение:
```javascript
function minCoinsSingleCoin(coin, amount) {
  if (amount % coin === 0) {
    return amount / coin;
  }
  return -1;
}

console.log(minCoinsSingleCoin(5, 20));  // 4
console.log(minCoinsSingleCoin(3, 7));   // -1
```
Объяснение:
Если сумма делится на номинал монеты, то минимальное количество монет равно сумме, деленной на этот номинал. Если деление не нацело, размен невозможен.
---
4. ⌛ Задача: Невозможный размен
Условие:
Даны монеты и сумма. Нужно вернуть `true`, если размен суммы невозможен с использованием данных монет, и `false` в противном случае.
🎯 Решение:
```javascript
function isPossible(coins, amount) {
  const dp = Array(amount + 1).fill(false);
  dp[0] = true;

  for (let coin of coins) {
    for (let i = coin; i <= amount; i++) {
      dp[i] = dp[i] || dp[i - coin];
    }
  }

  return dp[amount];
}

console.log(isPossible([1, 2, 5], 11));  // true
console.log(isPossible([2, 5], 7));      // false
```
Объяснение:
Создаем массив `dp`, где `dp[i]` хранит информацию о том, возможно ли разменять сумму `i`. Мы поочередно проверяем все монеты, обновляя массив.
---
5. ⌛ Задача: Размен с минимальной суммой дополнительного остатка
Условие:
Нужно найти минимальное количество монет, при котором остаток при размене будет минимален.
🎯 Решение:
```javascript
function minCoinsWithRemainder(coins, amount) {
  const dp = Array(amount + 1).fill(Infinity);
  dp[0] = 0;

  for (let i = 1; i <= amount; i++) {
    for (let coin of coins) {
      if (i >= coin) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1);
      }
    }
  }

  return dp[amount] === Infinity ? -1 : dp[amount];
}

console.log(minCoinsWithRemainder([1, 2, 5], 7));  // 2
```
Объяснение:
Задача аналогична предыдущей, но здесь нам важно минимизировать остаток. Мы вычисляем количество монет, которое дает минимальный остаток при размене.
---
6. ⌛ Задача: Размен для всех возможных сумм от 0 до N
Условие:
Нужно найти минимальное количество монет для всех возможных сумм от 0 до N.
🎯 Решение:
```javascript
function coinChangeAll(coins, N) {
  const dp = Array(N + 1).fill(Infinity);
  dp[0] = 0;

  for (let i = 1; i <= N; i++) {
    for (let coin of coins) {
      if (i >= coin) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1);
      }
    }
  }

  return dp.slice(0, N + 1);
}

console.log(coinChangeAll([1, 2, 5], 11));
```
Объяснение:
Мы строим массив `dp`, в котором для каждой суммы от 0 до N содержится минимальное количество монет для размена.
---
7. ⌛ Задача: Размен с учетом минимальной монеты для каждого номинала
Условие:
Для каждого номинала монеты нужно использовать минимальное количество монет. Разменяйте сумму с минимальными затратами.
🎯 Решение:
```javascript
function minCoinsForEachCoin(coins, amount) {
  const dp = Array(amount + 1).fill(Infinity);
  dp[0] = 0;

  for (let i = 1; i <= amount; i++) {
    for (let coin of coins) {
      if (i >= coin) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1);
      }
    }
  }

  return dp[amount] === Infinity ? -1 : dp[amount];
}

console.log(minCoinsForEachCoin([1, 2, 5], 7));  // 2
```
Объяснение:
Подход аналогичен предыдущим задачам, но ключевое отличие заключается в том, что мы применяем минимальные монеты для размена.
---
8. ⌛ Задача: Проверка наличия достаточного количества монет для размена
Условие:
Даны монеты и их количество. Нужно проверить, можно ли разменять сумму с учетом ограничений по количеству монет.
🎯 Решение:
```javascript
function isExchangePossible(coins, amounts, total) {
  let sum = 0;
  for (let i = 0; i < coins.length; i++) {
    sum += Math.min(Math.floor(total / coins[i]), amounts[i]);
    total -= sum * coins[i];
  }
  return total === 0;
}

console.log(isExchangePossible([1, 2, 5], [2, 2, 1], 7));  // true
```
Объяснение:
Для каждой монеты проверяется, сколько монет можно использовать, чтобы достичь нужной суммы, с учётом ограничений.
---
9. ⌛ Задача: Размен суммы с обратной связью (монеты с "возвращением")
Условие:
Есть монеты с возможностью их возврата. Нужно найти минимальное количество монет для размена суммы, при этом учесть, что монеты могут быть возвращены.
🎯 Решение:
```javascript
function minCoinsWithReturn(coins, amount) {
  const dp = Array(amount + 1).fill(Infinity);
  dp[0] = 0;

  for (let i = 1; i <= amount; i++) {
    for (let coin of coins) {
      if (i >= coin) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1);
      }
    }
  }

  return dp[amount] === Infinity ? -1 : dp[amount];
}

console.log(minCoinsWithReturn([1, 2, 5], 7));  // 2
```
Объяснение:
В этом решении также используется динамическое программирование, но в условиях задачи учитываются особенности возврата монет, которые могут влиять на итоговое количество монет для размена.
---
10. ⌛ Задача: Размен с минимальными потерями
Условие:
Нужно найти минимальные потери при размене суммы, если размен невозможен. Потери — это разница между суммой и минимально возможной суммой, которую можно получить.
🎯 Решение:
```javascript
function minLoss(coins, amount) {
  const dp = Array(amount + 1).fill(Infinity);
  dp[0] = 0;

  for (let i = 1; i <= amount; i++) {
    for (let coin of coins) {
      if (i >= coin) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1);
      }
    }
  }

  return dp[amount] === Infinity ? amount : dp[amount];
}

console.log(minLoss([1, 2, 5], 7));  // 2
```
Объяснение:
В случае невозможности размена суммы мы вычисляем минимальные потери, то есть разницу между целью и ближайшей возможной суммой.
Эти задачи демонстрируют различные подходы к решению задачи размена с использованием динамического программирования, проверок на невозможность размена и других техник.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& 
Вот 10 более сложных задач, связанных с разменом монет (или аналогичными задачами), которые можно решить с использованием различных техник, включая динамическое программирование и жадные алгоритмы.
1. ⌛ Задача: Размен с возвратом монет (ограничение по количеству)
Условие:
Есть набор монет с ограничением по количеству для каждого номинала. Нужно найти минимальное количество монет, чтобы разменять сумму. При этом если размен невозможен, вернуть -1.
🎯 Решение:
```javascript
function minCoinsWithReturn(coins, amounts, total) {
  const dp = Array(total + 1).fill(Infinity);
  dp[0] = 0;

  for (let i = 0; i < coins.length; i++) {
    for (let j = total; j >= coins[i]; j--) {
      for (let k = 1; k <= amounts[i] && k * coins[i] <= j; k++) {
        dp[j] = Math.min(dp[j], dp[j - k * coins[i]] + k);
      }
    }
  }

  return dp[total] === Infinity ? -1 : dp[total];
}

console.log(minCoinsWithReturn([1, 2, 5], [2, 2, 1], 7));  // 3
```
Объяснение:
Задача решается с помощью динамического программирования, где для каждого номинала проверяется, сколько раз его можно использовать для размена суммы, с учётом ограничения на количество монет.
---
2. ⌛ Задача: Размен с минимальной стоимостью (с учётом номиналов и ограничений)
Условие:
У нас есть несколько номиналов монет, и для каждого номинала ограничено количество монет. Нужно найти минимальное количество монет, которое потребуется для размена суммы. Если это невозможно, вернуть -1.
🎯 Решение:
```javascript
function minCoinsWithLimits(coins, limits, total) {
  const dp = Array(total + 1).fill(Infinity);
  dp[0] = 0;

  for (let i = 0; i < coins.length; i++) {
    for (let j = 0; j < total + 1; j++) {
      for (let k = 1; k <= limits[i]; k++) {
        if (j >= k * coins[i]) {
          dp[j] = Math.min(dp[j], dp[j - k * coins[i]] + k);
        }
      }
    }
  }

  return dp[total] === Infinity ? -1 : dp[total];
}

console.log(minCoinsWithLimits([1, 2, 5], [2, 2, 1], 7));  // 3
```
Объяснение:
Задача требует динамического подхода с учётом ограничения по количеству монет для каждого номинала. Мы применяем динамическое программирование и на каждом шаге проверяем, сколько раз можем использовать монеты, чтобы разменять сумму.
---
3. ⌛ Задача: Размен с минимальной разницей
Условие:
Даны несколько номиналов монет, нужно найти минимальное количество монет, которое можно использовать для размена суммы. Если невозможно разменять точно, вернуть минимальное количество монет, которые составляют сумму, близкую к нужной.
🎯 Решение:
```javascript
function minCoinsWithDifference(coins, total) {
  const dp = Array(total + 1).fill(Infinity);
  dp[0] = 0;

  for (let i = 0; i < coins.length; i++) {
    for (let j = coins[i]; j <= total; j++) {
      dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
    }
  }

  return dp[total] === Infinity ? -1 : dp[total];
}

console.log(minCoinsWithDifference([1, 2, 5], 7));  // 2
console.log(minCoinsWithDifference([1, 3, 4], 6));  // 2
```
Объяснение:
Этот алгоритм использует динамическое программирование для нахождения минимального количества монет. В случае, если точное разбиение суммы невозможно, программа всё равно возвращает минимальное количество монет, которые можно использовать для получения максимально близкой суммы.
---
4. ⌛ Задача: Невозможный размен с минимальными потерями
Условие:
Нужно найти размен суммы с минимальными потерями. Потери — это разница между заданной суммой и суммой, которую можно составить из данных монет.
🎯 Решение:
```javascript
function minLoss(coins, amount) {
  const dp = Array(amount + 1).fill(Infinity);
  dp[0] = 0;

  for (let i = 0; i < coins.length; i++) {
    for (let j = coins[i]; j <= amount; j++) {
      dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
    }
  }

  let result = dp[amount];
  if (result === Infinity) {
    for (let i = amount - 1; i >= 0; i--) {
      if (dp[i] !== Infinity) {
        result = dp[i];
        break;
      }
    }
  }

  return result === Infinity ? -1 : result;
}

console.log(minLoss([1, 2, 5], 7));  // 2
```
Объяснение:
Мы используем динамическое программирование для нахождения минимального количества монет, которые могут быть использованы для размена суммы. В случае невозможности точного размена, программа находит сумму с минимальными потерями.
---
5. ⌛ Задача: Размен с ограничением на максимальное количество монет для разменной суммы
Условие:
Есть монеты с ограниченным количеством каждой. Нужно найти минимальное количество монет для размена суммы, при этом учитывать максимальное количество монет для каждой суммы.
🎯 Решение:
```javascript
function minCoinsMaxLimit(coins, limits, total) {
  const dp = Array(total + 1).fill(Infinity);
  dp[0] = 0;

  for (let i = 0; i < coins.length; i++) {
    for (let j = total; j >= coins[i]; j--) {
      for (let k = 1; k <= limits[i] && k * coins[i] <= j; k++) {
        dp[j] = Math.min(dp[j], dp[j - k * coins[i]] + k);
      }
    }
  }

  return dp[total] === Infinity ? -1 : dp[total];
}

console.log(minCoinsMaxLimit([1, 2, 5], [3, 3, 2], 7));  // 3
```
Объяснение:
Для каждой монеты учитывается её ограниченное количество. Мы используем динамическое программирование с дополнительной проверкой на максимальное количество монет.
---
6. ⌛ Задача: Найти наибольшую возможную сумму для размена
Условие:
Нужно найти максимальную сумму, которую можно составить из заданного набора монет с ограничениями на их количество.
🎯 Решение:
```javascript
function maxPossibleAmount(coins, limits) {
  let maxAmount = 0;
  for (let i = 0; i < coins.length; i++) {
    maxAmount += coins[i] * limits[i];
  }
  return maxAmount;
}

console.log(maxPossibleAmount([1, 2, 5], [3, 3, 2]));  // 16
```
Объяснение:
Здесь просто нужно вычислить максимальную сумму, которая может быть получена, если использовать все доступные монеты в максимально возможном количестве.
---
7. ⌛ Задача: Размен с минимальным остатком
Условие:
Нужно разменять сумму с минимальным остатком, используя монеты различных номиналов.
🎯 Решение:
```javascript
function minRemainder(coins, amount) {
  const dp = Array(amount + 1).fill(false);
  dp[0] = true;

  for (let i = 0; i < coins.length; i++) {
    for (let j = coins[i]; j <= amount; j++) {
      dp[j] = dp[j] || dp[j - coins[i]];
    }
  }

  for (let i = amount; i >= 0; i--) {
    if (dp[i]) {
      return amount - i;
    }
  }

  return -1;
}

console.log(minRemainder([1, 2, 5], 7));  // 0
```
Объяснение:
Используя динамическое программирование, мы находим максимально возможную сумму, которую можно получить, не превышая нужную сумму. Остаток будет разницей между целевой суммой и найденной суммой.
---
8. ⌛ Задача: Размен с учётом всех возможных вариантов
Условие:
Нужно найти все возможные способы размена суммы с использованием данных монет и вывести все комбинации.
🎯 Решение:
```javascript
function coinCombinations(coins, amount) {
  const dp = Array(amount + 1).fill(0);
  dp[0] = 1;

  for (let coin of coins) {
    for (let i = coin; i <= amount; i++) {
      dp[i]

 += dp[i - coin];
    }
  }

  return dp[amount];
}

console.log(coinCombinations([1, 2, 5], 7));  // 6
```
Объяснение:
Используем динамическое программирование, чтобы посчитать количество возможных комбинаций монет для размена суммы.
---
9. ⌛ Задача: Размен с дополнительным ограничением (монеты, не превышающие максимальную цену)
Условие:
Нужно найти минимальное количество монет, которые можно использовать для размена суммы с дополнительным ограничением на максимальную цену монет.
🎯 Решение:
```javascript
function minCoinsWithMaxValue(coins, total, maxCoin) {
  coins = coins.filter(coin => coin <= maxCoin);
  const dp = Array(total + 1).fill(Infinity);
  dp[0] = 0;

  for (let coin of coins) {
    for (let i = coin; i <= total; i++) {
      dp[i] = Math.min(dp[i], dp[i - coin] + 1);
    }
  }

  return dp[total] === Infinity ? -1 : dp[total];
}

console.log(minCoinsWithMaxValue([1, 2, 5], 7, 2));  // 3
```
Объяснение:
Этот алгоритм сначала фильтрует монеты, исключая те, которые больше заданного ограничения, и затем решает задачу размена.
---
10. ⌛ Задача: Размен с учетом старых монет (если размен невозможен)
Условие:
Если размен невозможен, нужно найти наименьший размен, который можно осуществить с использованием старых монет.
🎯 Решение:
```javascript
function minCoinsWithOld(coins, total) {
  const dp = Array(total + 1).fill(Infinity);
  dp[0] = 0;

  for (let i = 0; i < coins.length; i++) {
    for (let j = coins[i]; j <= total; j++) {
      dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
    }
  }

  if (dp[total] === Infinity) {
    return dp[total - 1];
  }

  return dp[total];
}

console.log(minCoinsWithOld([1, 2, 5], 7));  // 2
```
Объяснение:
Здесь используется динамическое программирование для поиска минимального размена с учётом старых монет, если точный размен невозможен.
Эти задачи требуют более сложных техник и решений, часто с учётом множества факторов, таких как ограничения на количество монет, жадные алгоритмы и более подробное использование динамического программирования.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& 
---------------------
⋙ ❍ Задача «Простой калькулятор»:
---
⌛ Задача 1: Сложение двух чисел
Условие:
Напишите функцию, которая принимает два числа и возвращает их сумму.
🎯 Решение:
```javascript
function add(a, b) {
  return a + b;
}

console.log(add(5, 3));  // 8
```
Объяснение:
Это самая базовая операция сложения. Функция принимает два числа и возвращает их сумму.
---
⌛ Задача 2: Вычитание двух чисел
Условие:
Напишите функцию, которая принимает два числа и возвращает их разницу.
🎯 Решение:
```javascript
function subtract(a, b) {
  return a - b;
}

console.log(subtract(5, 3));  // 2
```
Объяснение:
Здесь мы используем стандартную операцию вычитания, чтобы найти разницу между двумя числами.
---
⌛ Задача 3: Умножение двух чисел
Условие:
Напишите функцию, которая принимает два числа и возвращает их произведение.
🎯 Решение:
```javascript
function multiply(a, b) {
  return a * b;
}

console.log(multiply(5, 3));  // 15
```
Объяснение:
Здесь мы умножаем два числа и возвращаем результат.
---
⌛ Задача 4: Деление двух чисел
Условие:
Напишите функцию, которая принимает два числа и возвращает результат их деления. Учтите, что деление на 0 не должно происходить.
🎯 Решение:
```javascript
function divide(a, b) {
  if (b === 0) {
    return 'Error: Division by zero';
  }
  return a / b;
}

console.log(divide(6, 3));  // 2
console.log(divide(5, 0));  // 'Error: Division by zero'
```
Объяснение:
Мы проверяем, если делитель равен 0, и в таком случае возвращаем ошибку. Если деление возможно, возвращаем результат.
---
⌛ Задача 5: Возведение в степень
Условие:
Напишите функцию, которая принимает два числа: основание и степень, и возвращает результат возведения основания в степень.
🎯 Решение:
```javascript
function power(base, exponent) {
  return Math.pow(base, exponent);
}

console.log(power(2, 3));  // 8
```
Объяснение:
Используем стандартную функцию `Math.pow`, чтобы возвести число в заданную степень.
---
⌛ Задача 6: Калькулятор с несколькими операциями
Условие:
Напишите функцию, которая принимает три аргумента: два числа и операцию, и возвращает результат операции (сложение, вычитание, умножение или деление).
🎯 Решение:
```javascript
function calculator(a, b, operation) {
  switch (operation) {
    case 'add':
      return a + b;
    case 'subtract':
      return a - b;
    case 'multiply':
      return a * b;
    case 'divide':
      if (b === 0) {
        return 'Error: Division by zero';
      }
      return a / b;
    default:
      return 'Invalid operation';
  }
}

console.log(calculator(5, 3, 'add'));       // 8
console.log(calculator(5, 3, 'subtract'));  // 2
console.log(calculator(5, 3, 'multiply'));  // 15
console.log(calculator(5, 0, 'divide'));    // 'Error: Division by zero'
```
Объяснение:
Мы используем `switch` для выбора операции на основе аргумента `operation`. Это позволяет легко расширить калькулятор, добавляя новые операции.
---
⌛ Задача 7: Подсчёт факториала
Условие:
Напишите функцию, которая принимает число и возвращает его факториал.
🎯 Решение:
```javascript
function factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  }
  let result = 1;
  for (let i = 2; i <= n; i++) {
    result *= i;
  }
  return result;
}

console.log(factorial(5));  // 120
```
Объяснение:
Мы используем цикл, чтобы перемножить все числа от 1 до `n`, получая факториал числа.
---
⌛ Задача 8: Проверка на простое число
Условие:
Напишите функцию, которая проверяет, является ли число простым.
🎯 Решение:
```javascript
function isPrime(n) {
  if (n <= 1) return false;
  for (let i = 2; i <= Math.sqrt(n); i++) {
    if (n % i === 0) return false;
  }
  return true;
}

console.log(isPrime(7));  // true
console.log(isPrime(10)); // false
```
Объяснение:
Для проверки простоты числа мы делим его на все числа от 2 до квадратного корня из числа. Если ни одно из делений не даёт целочисленного результата, число простое.
---
⌛ Задача 9: Нахождение квадратного корня
Условие:
Напишите функцию, которая принимает число и возвращает его квадратный корень.
🎯 Решение:
```javascript
function squareRoot(n) {
  if (n < 0) {
    return 'Error: Negative number';
  }
  return Math.sqrt(n);
}

console.log(squareRoot(9));  // 3
console.log(squareRoot(-9)); // 'Error: Negative number'
```
Объяснение:
Используем функцию `Math.sqrt` для нахождения квадратного корня. Также добавлена проверка на отрицательные числа, так как для них квадратный корень не существует в области вещественных чисел.
---
⌛ Задача 10: Ввод данных и выполнение операции через prompt
Условие:
Напишите калькулятор, который принимает два числа и операцию через `prompt` и выводит результат.
🎯 Решение:
```javascript
function simpleCalculator() {
  const a = parseFloat(prompt('Enter the first number:'));
  const b = parseFloat(prompt('Enter the second number:'));
  const operation = prompt('Enter the operation (add, subtract, multiply, divide):');

  switch (operation) {
    case 'add':
      alert(a + b);
      break;
    case 'subtract':
      alert(a - b);
      break;
    case 'multiply':
      alert(a * b);
      break;
    case 'divide':
      if (b === 0) {
        alert('Error: Division by zero');
      } else {
        alert(a / b);
      }
      break;
    default:
      alert('Invalid operation');
  }
}

simpleCalculator();
```
Объяснение:
В этой задаче мы используем `prompt` для ввода данных и `alert` для вывода результата. Код взаимодействует с пользователем через диалоговые окна.
Эти задачи покрывают основные операции калькулятора, такие как сложение, вычитание, умножение, деление и несколько более сложных задач, таких как факториал, проверка на простоту и квадратный корень.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& 
---------------------
⋙ ❍ Задача «Расстояние редактирования»:
---
Задача о расстоянии редактирования (или расстоянии Левенштейна) — это классическая задача, которая вычисляет минимальное количество операций, необходимых для преобразования одной строки в другую. Операции могут быть следующими:
1. Вставка символа.
2. Удаление символа.
3. Замена символа на другой.
Давайте рассмотрим несколько задач с решениями и объяснениями на языке JavaScript для задачи о расстоянии редактирования.
1️⃣ Базовая задача: Вычисление расстояния редактирования между двумя строками
⌛ Задача: Найдите расстояние редактирования между двумя строками.
🎯 Решение:
```js
function editDistance(str1, str2) {
  const m = str1.length;
  const n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 0; i <= m; i++) {
    for (let j = 0; j <= n; j++) {
      if (i === 0) dp[i][j] = j; // Если первая строка пустая, нужно вставить все символы из второй строки
      else if (j === 0) dp[i][j] = i; // Если вторая строка пустая, нужно удалить все символы из первой строки
      else if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1]; // Если символы одинаковы, ничего не меняем
      } else {
        dp[i][j] = Math.min(
          dp[i - 1][j - 1], // Замена
          dp[i - 1][j], // Удаление
          dp[i][j - 1]  // Вставка
        ) + 1;
      }
    }
  }

  return dp[m][n];
}

console.log(editDistance("kitten", "sitting")); // 3
```
Объяснение: Мы используем динамическое программирование для вычисления расстояния редактирования. Таблица `dp` хранит минимальное количество операций для каждой подстроки.
---
2️⃣ Задача: Расстояние редактирования для строк с одинаковыми буквами
⌛ Задача: Найдите расстояние редактирования для строк с одинаковыми буквами, но разным порядком.
🎯 Решение:
```js
function editDistance(str1, str2) {
  const m = str1.length;
  const n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 0; i <= m; i++) {
    for (let j = 0; j <= n; j++) {
      if (i === 0) dp[i][j] = j;
      else if (j === 0) dp[i][j] = i;
      else if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = Math.min(
          dp[i - 1][j - 1],
          dp[i - 1][j],
          dp[i][j - 1]
        ) + 1;
      }
    }
  }

  return dp[m][n];
}

console.log(editDistance("abc", "cba")); // 2
```
Объяснение: Строки одинаковы по набору символов, но символы в них расположены в разном порядке. Нужно выполнить две операции — замена и перестановка.
---
3️⃣ Задача: Расстояние редактирования для пустых строк
⌛ Задача: Найдите расстояние редактирования между пустыми и непустыми строками.
🎯 Решение:
```js
function editDistance(str1, str2) {
  const m = str1.length;
  const n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 0; i <= m; i++) {
    for (let j = 0; j <= n; j++) {
      if (i === 0) dp[i][j] = j;
      else if (j === 0) dp[i][j] = i;
      else if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = Math.min(
          dp[i - 1][j - 1],
          dp[i - 1][j],
          dp[i][j - 1]
        ) + 1;
      }
    }
  }

  return dp[m][n];
}

console.log(editDistance("", "hello")); // 5
```
Объяснение: Если одна из строк пуста, то минимальное количество операций равно длине другой строки (необходимо только вставить или удалить все символы).
---
4️⃣ Задача: Расстояние редактирования для одинаковых строк
⌛ Задача: Найдите расстояние редактирования для одинаковых строк.
🎯 Решение:
```js
function editDistance(str1, str2) {
  const m = str1.length;
  const n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 0; i <= m; i++) {
    for (let j = 0; j <= n; j++) {
      if (i === 0) dp[i][j] = j;
      else if (j === 0) dp[i][j] = i;
      else if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = Math.min(
          dp[i - 1][j - 1],
          dp[i - 1][j],
          dp[i][j - 1]
        ) + 1;
      }
    }
  }

  return dp[m][n];
}

console.log(editDistance("hello", "hello")); // 0
```
Объяснение: Если строки одинаковы, то количество операций будет равно нулю, так как изменений не требуется.
---
5️⃣ Задача: Расстояние редактирования для строк разной длины
⌛ Задача: Найдите расстояние редактирования между строками разной длины.
🎯 Решение:
```js
function editDistance(str1, str2) {
  const m = str1.length;
  const n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 0; i <= m; i++) {
    for (let j = 0; j <= n; j++) {
      if (i === 0) dp[i][j] = j;
      else if (j === 0) dp[i][j] = i;
      else if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = Math.min(
          dp[i - 1][j - 1],
          dp[i - 1][j],
          dp[i][j - 1]
        ) + 1;
      }
    }
  }

  return dp[m][n];
}

console.log(editDistance("abc", "abcdef")); // 3
```
Объяснение: Строки разной длины требуют вставки символов в более короткую строку или удаления символов из более длинной.
---
6️⃣ Задача: Расстояние редактирования для строк с разными символами
⌛ Задача: Найдите расстояние редактирования для строк, которые содержат разные символы.
🎯 Решение:
```js
function editDistance(str1, str2) {
  const m = str1.length;
  const n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 0; i <= m; i++) {
    for (let j = 0; j <= n; j++) {
      if (i === 0) dp[i][j] = j;
      else if (j === 0) dp[i][j] = i;
      else if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = Math.min(
          dp[i - 1][j - 1],
          dp[i - 1][j],
          dp[i][j - 1]
        ) + 1;
      }
    }
  }

  return dp[m][n];
}

console.log(editDistance("abc", "xyz")); // 3
```
Объяснение: Строки содержат разные символы, поэтому минимальное количество операций — три замены.
---
7️⃣ Задача: Задача с минимальной длиной строки
⌛ Задача: Найдите расстояние редактирования для строки, которая является подстрокой другой строки.
🎯 Решение:
```js
function editDistance(str1, str2) {
  const m = str1.length;
  const n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 0; i <= m; i++) {
    for (let j = 0; j <= n; j++) {
      if (i === 0) dp[i][j] = j;
      else if (j === 0) dp[i][j] = i;
      else if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = Math.min(
          dp[i - 1][j - 1],
          dp[i - 1][j],
          dp[i][j - 1]
        ) + 1;
      }
    }
  }

  return dp[m][n];
}

console.log(editDistance("hello", "hell")); // 1
```
Объяснение: Если одна строка является подстрокой другой, то нужно просто удалить символы, которые не присутствуют в подстроке.
---
8️⃣ Задача: Использование разных алфавитов
⌛ Задача: Найдите расстояние редактирования для строк, содержащих символы разных алфавитов.
🎯 Решение:
```js
function editDistance(str1, str2) {
  const m = str1.length;
  const n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 0; i <= m; i++) {
    for (let j = 0; j <= n; j++) {
      if (i === 0) dp[i][j] = j;
      else if (j === 0) dp[i][j] = i;
      else if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = Math.min(
          dp[i - 1][j - 1],
          dp[i - 1][j],
          dp[i][j - 1]
        ) + 1;
      }
    }
  }

  return dp[m][n];
}

console.log(editDistance("abc", "123")); // 3
```
Объяснение: Строки содержат разные символы, и для их приведения друг к другу потребуется три операции.
---
9️⃣ Задача с повторами символов
⌛ Задача: Найдите расстояние редактирования для строк, содержащих одинаковые символы, но в разном количестве.
🎯 Решение:
```js
function editDistance(str1, str2) {
  const m = str1.length;
  const n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 0; i <= m; i++) {
    for (let j = 0; j <= n; j++) {
      if (i === 0) dp[i][j] = j;
      else if (j === 0) dp[i][j] = i;
      else if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = Math.min(
          dp[i - 1][j - 1],
          dp[i - 1][j],
          dp[i][j - 1]
        ) + 1;
      }
    }
  }

  return dp[m][n];
}

console.log(editDistance("aaabbb", "ababab")); // 3
```
Объяснение: В данном случае необходимо выполнить несколько операций вставки или удаления символов для согласования строк.
---
🔟 Задача с длинными строками
⌛ Задача: Найдите расстояние редактирования между очень длинными строками.
🎯 Решение:
```js
function editDistance(str1, str2) {
  const m = str1.length;
  const n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 0; i <= m; i++) {
    for (let j = 0; j <= n; j++) {
      if (i === 0) dp[i][j] = j;
      else if (j === 0) dp[i][j] = i;
      else if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = Math.min(
          dp[i - 1][j - 1],
          dp[i - 1][j],
          dp[i][j - 1]
        ) + 1;
      }
    }
  }

  return dp[m][n];
}

console.log(editDistance("a".repeat(1000), "b".repeat(1000))); // 1000
```
 Объяснение: Для очень длинных строк количество операций будет линейным по отношению к длине строк.
   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& 
---------------------
⋙ ❍ Задача LCS:
---
Задача: Longest Common Subsequence (LCS) — это классическая задача динамического программирования, которая заключается в нахождении наибольшей общей подпоследовательности двух строк. Подпоследовательность — это последовательность символов, которая может быть получена из другой строки путем удаления некоторых (или вообще всех) символов, не меняя порядка оставшихся символов.
Пример: для строк `"AGGTAB"` и `"GXTXAYB"`, наибольшая общая подпоследовательность — это `"GTAB"`.
1️⃣ Базовая задача LC
⌛ Задача: Найдите наибольшую общую подпоследовательность (LCS) двух строк.
🎯 Решение:
```js
function lcs(str1, str2) {
  const m = str1.length, n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  return dp[m][n];
}

console.log(lcs("AGGTAB", "GXTXAYB")); // 4
```Объяснение В этом решении мы используем таблицу динамического программирования (`dp`), чтобы хранить длину LCS для каждой подстроки. Каждый элемент `dp[i][j]` представляет длину LCS для первых `i` символов строки `str1` и первых `j` символов строки `str2`.
---
2️⃣ ⌛ Задача на восстановление LCЗадача Найдите не только длину LCS, но и саму подпоследовательность.
🎯 Решение:
```js
function lcsWithSequence(str1, str2) {
  const m = str1.length, n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  let lcsString = '';
  let i = m, j = n;
  while (i > 0 && j > 0) {
    if (str1[i - 1] === str2[j - 1]) {
      lcsString = str1[i - 1] + lcsString;
      i--;
      j--;
    } else if (dp[i - 1][j] > dp[i][j - 1]) {
      i--;
    } else {
      j--;
    }
  }

  return lcsString;
}

console.log(lcsWithSequence("AGGTAB", "GXTXAYB")); // GTAB
```Объяснение Мы строим таблицу, как в предыдущем решении, но после вычисления длины LCS, мы восстанавливаем саму подпоследовательность, двигаясь по таблице обратно.
---
3️⃣ ⌛ Задача с пустой строкоЗадача Найдите LCS двух строк, одна из которых пуста.
🎯 Решение:
```js
function lcs(str1, str2) {
  const m = str1.length, n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  return dp[m][n];
}

console.log(lcs("", "ABCD")); // 0
```Объяснение Если одна из строк пуста, то длина их LCS будет равна нулю.
---
4️⃣ ⌛ Задача с одинаковыми строкамЗадача Найдите LCS двух одинаковых строк.
🎯 Решение:
```js
function lcs(str1, str2) {
  const m = str1.length, n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  return dp[m][n];
}

console.log(lcs("ABCDE", "ABCDE")); // 5
```Объяснение Если строки одинаковы, то LCS будет равно длине этих строк.
---
5️⃣ ⌛ Задача на использование различных алфавитоЗадача Найдите LCS для строк с разными наборами символов (например, строки с разными языками).
🎯 Решение:
```js
function lcs(str1, str2) {
  const m = str1.length, n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  return dp[m][n];
}

console.log(lcs("абвгде", "гдеабв")); // 3
```Объяснение Алфавит не имеет значения, поскольку мы просто сравниваем символы в строках.
---
6️⃣ ⌛ Задача на LCS для двух строк с пробеламЗадача Найдите LCS двух строк, которые содержат пробелы.
🎯 Решение:
```js
function lcs(str1, str2) {
  const m = str1.length, n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  return dp[m][n];
}

console.log(lcs("hello world", "helloworld")); // 10
```Объяснение Пробелы считаются символами, и они участвуют в поиске общей подпоследовательности.
---
7️⃣ ⌛ Задача с большими строкамЗадача Найдите LCS для длинных строк.
🎯 Решение:
```js
function lcs(str1, str2) {
  const m = str1.length, n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  return dp[m][n];
}

const str1 = "A".repeat(1000) + "B".repeat(1000);
const str2 = "A".repeat(500) + "B".repeat(1000);
console.log(lcs(str1, str2)); // 1500
```
Объяснение Алгоритм динамического программирования эффективно решает задачу даже для длинных строк, но при больших строках возможна высокая временная сложность.
---
8️⃣ ⌛ Задача на LCS для числовых строЗадача Найдите LCS для строк, содержащих только числа.
🎯 Решение:
```js
function lcs(str1, str2) {
  const m = str1.length, n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  return dp[m][n];
}

console.log(lcs("123456", "13524")); // 3
```Объяснение Задача LCS работает так же, независимо от того, какие символы содержатся в строках.
---
9️⃣ ⌛ Задача на LCS для последовательности слоЗадача Найдите LCS для двух строк, где каждое слово разделено пробелом.
🎯 Решение:
```js
function lcs(str1, str2) {
  const words1 = str1.split(' '), words2 = str2.split(' ');
  const m = words1.length, n = words2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (words1[i - 1] === words2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  return dp[m][n];
}

console.log(lcs("I love programming", "I love coding")); // 2
```Объяснение Мы разделяем строки на слова и находим наибольшую общую подпоследовательность для слов.
---
🔟 ⌛ Задача на LCS для строки с цифрами и буквамЗадача Найдите LCS для строки, содержащей и цифры, и буквы.
🎯 Решение:
```js
function lcs(str1, str2) {
  const m = str1.length, n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  return dp[m][n];
}

console.log(lcs("abc123", "abc321")); // 3
```Объяснение Решение аналогично предыдущим примерам, только строки содержат и цифры, и буквы.
Эти задачи помогают разобраться в решении задачи LCS с различными вариантами входных данных и ситуациями.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& 
---------------------
⋙ ❍ Задача о рюкзаке:
---
Задача о рюкзаке (или задача о рюкзаке с ограничениями) — это классическая задача оптимизации, в которой нужно выбрать набор предметов (сувениров, товаров и т.д.) таким образом, чтобы максимизировать их стоимость при условии, что их общий вес не превышает заданного ограничения. Этот тип задачи часто используется в алгоритмах для нахождения наилучшего выбора при ограниченных ресурсах (например, объем или вес рюкзака).
1️⃣ Базовая задача о рюкзаке (0/1)
⌛ Задача: Даны предметы с весами и ценами. Напишите функцию, которая определяет максимальную стоимость, которую можно взять в рюкзак с ограничением по весу.
🎯 Решение:
```js
function knapsack(items, capacity) {
  const n = items.length;
  const dp = Array(n + 1).fill().map(() => Array(capacity + 1).fill(0));

  for (let i = 1; i <= n; i++) {
    for (let w = 1; w <= capacity; w++) {
      if (items[i - 1].weight <= w) {
        dp[i][w] = Math.max(dp[i - 1][w], dp[i - 1][w - items[i - 1].weight] + items[i - 1].value);
      } else {
        dp[i][w] = dp[i - 1][w];
      }
    }
  }
  return dp[n][capacity];
}

const items = [
  { value: 60, weight: 10 },
  { value: 100, weight: 20 },
  { value: 120, weight: 30 }
];

console.log(knapsack(items, 50)); // 220
```
Объяснение:
- Решение основывается на динамическом программировании. Мы строим таблицу `dp`, где ячейка `dp[i][w]` содержит максимальную стоимость для первых `i` предметов при ограничении по весу `w`. Для каждого предмета мы решаем, включать ли его в рюкзак.
---
2️⃣ Задача с большим количеством предметов и рюкзаком
⌛Задача: У вас есть 100 предметов и рюкзак с весом 100. Напишите решение для данной задачи, учитывая большую длину входных данных.
🎯 Решение:
```js
function knapsackLarge(items, capacity) {
  const dp = Array(capacity + 1).fill(0);

  items.forEach(item => {
    for (let w = capacity; w >= item.weight; w--) {
      dp[w] = Math.max(dp[w], dp[w - item.weight] + item.value);
    }
  });

  return dp[capacity];
}

const items = Array(100).fill().map((_, i) => ({ value: (i + 1) * 10, weight: i + 1 }));
console.log(knapsackLarge(items, 100)); // 5050
```
Объяснение:
- Используется одномерный массив `dp`, где каждая ячейка хранит максимальную стоимость для определенного веса рюкзака. Мы начинаем с максимального веса и проходим по всем предметам.
---
3️⃣ Задача с рюкзаком и повторяющимися предметами (разрешены многократные включения)
⌛Задача: В отличие от предыдущей задачи, теперь предметы можно повторно включать в рюкзак. Напишите решение для задачи с множественным выбором предметов.
🎯 Решение:
```js
function unboundedKnapsack(items, capacity) {
  const dp = Array(capacity + 1).fill(0);

  items.forEach(item => {
    for (let w = item.weight; w <= capacity; w++) {
      dp[w] = Math.max(dp[w], dp[w - item.weight] + item.value);
    }
  });

  return dp[capacity];
}

const items = [
  { value: 60, weight: 10 },
  { value: 100, weight: 20 },
  { value: 120, weight: 30 }
];

console.log(unboundedKnapsack(items, 50)); // 300
```
Объяснение:
- В этом случае для каждого веса мы рассматриваем возможность многократного добавления одного и того же предмета в рюкзак.
---
4️⃣ Задача с ограниченным числом каждого предмета
⌛Задача: Каждый предмет можно положить в рюкзак не более определенного числа раз. Напишите решение для задачи с ограничением на количество предметов.
🎯 Решение:
```js
function boundedKnapsack(items, capacity) {
  const dp = Array(capacity + 1).fill(0);

  items.forEach(item => {
    for (let i = 0; i < item.quantity; i++) {
      for (let w = capacity; w >= item.weight; w--) {
        dp[w] = Math.max(dp[w], dp[w - item.weight] + item.value);
      }
    }
  });

  return dp[capacity];
}

const items = [
  { value: 60, weight: 10, quantity: 2 },
  { value: 100, weight: 20, quantity: 1 },
  { value: 120, weight: 30, quantity: 3 }
];

console.log(boundedKnapsack(items, 50)); // 240
```
Объяснение:
- Для каждого предмета мы поочередно учитываем его количество, что позволяет нам учитывать только определенное количество повторений этого предмета.
---
5️⃣ Взаимосвязь предметов и стоимостей
⌛Задача: У нас есть предметы, но каждый предмет имеет дополнительную зависимость от других предметов. Например, для того чтобы взять один предмет, нужно взять другой. Как решить такую задачу?
🎯 Решение:
```js
function dependencyKnapsack(items, capacity, dependencies) {
  const dp = Array(capacity + 1).fill(0);

  items.forEach(item => {
    const depItem = dependencies[item.name];
    if (depItem) {
      for (let w = capacity; w >= item.weight + depItem.weight; w--) {
        dp[w] = Math.max(dp[w], dp[w - item.weight - depItem.weight] + item.value + depItem.value);
      }
    } else {
      for (let w = capacity; w >= item.weight; w--) {
        dp[w] = Math.max(dp[w], dp[w - item.weight] + item.value);
      }
    }
  });

  return dp[capacity];
}

const items = [
  { name: "A", value: 60, weight: 10 },
  { name: "B", value: 100, weight: 20 },
  { name: "C", value: 120, weight: 30 }
];

const dependencies = {
  "A": { value: 20, weight: 5 },
  "B": { value: 50, weight: 15 }
};

console.log(dependencyKnapsack(items, 50, dependencies)); // 230
```
Объяснение:
- Для каждого предмета проверяется, есть ли зависимость. Если есть, то оба предмета считаются одновременно.
---
6️⃣ Применение задачи о рюкзаке для выбора задач в расписании
⌛Задача: У нас есть ограничение по времени на выполнение задач, и каждая задача имеет свою стоимость. Выберите задачи, чтобы максимизировать стоимость, не превышая времени.
🎯 Решение:
```js
function scheduleTasks(tasks, timeLimit) {
  const dp = Array(timeLimit + 1).fill(0);

  tasks.forEach(task => {
    for (let t = timeLimit; t >= task.time; t--) {
      dp[t] = Math.max(dp[t], dp[t - task.time] + task.value);
    }
  });

  return dp[timeLimit];
}

const tasks = [
  { value: 50, time: 2 },
  { value: 70, time: 3 },
  { value: 60, time: 1 },
];

console.log(scheduleTasks(tasks, 5)); // 120
```
Объяснение:
- Каждая задача имеет стоимость и время. Мы используем динамическое программирование для того, чтобы выбрать задачи с максимальной стоимостью, не превышая заданного времени.
---
7️⃣ Задача о рюкзаке для выбора программных решений
⌛Задача: У нас есть несколько программных решений для разных задач. Каждое решение имеет время работы и ценность для бизнеса. Выберите такие решения, чтобы минимизировать время и максимизировать ценность.
🎯 Решение:
```js
function chooseSolutions(solutions, timeLimit) {
  const dp = Array(timeLimit + 1).fill(0);

  solutions.forEach(solution => {
    for (let t = timeLimit; t >= solution.time; t--) {
      dp[t] = Math.max(dp[t], dp[t - solution.time] + solution.value);
    }
  });

  return dp[timeLimit];
}

const solutions = [
  { value: 120, time: 5 },
  { value: 60, time: 3 },
  { value: 80, time: 4 },
];

console.log(chooseSolutions(solutions, 8)); // 200
```
Объяснение:
- Задача схожа с задачей о рюкзаке, где мы пытаемся минимизировать время и максимизировать ценность решений.
---
8️⃣ Задача о рюкзаке для финансовых инвестиций
⌛Задача: У нас есть инвестиционные проекты с доходностью и временем. Выберите инвестиции, чтобы максимизировать доход, не превышая бюджетного времени.
🎯 Решение:
```js
function investmentProjects(projects, maxTime) {
  const dp = Array(maxTime + 1).fill(0);

  projects.forEach(project => {
    for (let t = maxTime; t >= project.time; t--) {
      dp[t] = Math.max(dp[t], dp[t - project.time] + project.profit);
    }
  });

  return dp[maxTime];
}

const projects = [
  { profit: 1000, time: 5 },
  { profit: 1500, time: 6 },
  { profit: 800, time: 2 },
];

console.log(investmentProjects(projects, 8)); // 2000
```
Объяснение:
- Мы решаем задачу оптимизации инвестиций, где цель — максимизировать прибыль, не выходя за пределы времени.
---
9️⃣ Задача о рюкзаке для минимизации потерь
⌛Задача: Напишите решение для задачи, в которой нужно минимизировать потери при выборе предметов с известными ценами и шансами на успех.
🎯 Решение:
```js
function minimizeLoss(items, maxWeight) {
  const dp = Array(maxWeight + 1).fill(0);

  items.forEach(item => {
    for (let w = maxWeight; w >= item.weight; w--) {
      dp[w] = Math.min(dp[w], dp[w - item.weight] + item.loss);
    }
  });

  return dp[maxWeight];
}

const items = [
  { loss: 50, weight: 10 },
  { loss: 30, weight: 5 },
  { loss: 20, weight: 3 }
];

console.log(minimizeLoss(items, 15)); // 80
```
Объяснение:
- Задача о минимизации потерь решается через динамическое программирование, где целью является минимизация потерь с учетом ограничений по весу.
---
🔟 Задача о рюкзаке с дополнительными ограничениями по стоимости
⌛Задача: Решите задачу о рюкзаке, где существуют ограничения на стоимость каждого предмета и максимальный вес рюкзака.
🎯 Решение:
```js
function knapsackWithConstraints(items, capacity, costLimit) {
  const dp = Array(capacity + 1).fill(0);

  items.forEach(item => {
    if (item.value <= costLimit) {
      for (let w = capacity; w >= item.weight; w--) {
        dp[w] = Math.max(dp[w], dp[w - item.weight] + item.value);
      }
    }
  });

  return dp[capacity];
}

const items = [
  { value: 60, weight: 10 },
  { value: 100, weight: 20 },
  { value: 120, weight: 30 }
];

console.log(knapsackWithConstraints(items, 50, 100)); // 220
```
Объяснение:
- Мы добавили дополнительное ограничение на максимальную стоимость предметов, которые могут быть выбраны.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& 
---------------------
⋙ ❍ Основные структуры данных:
---
Эти задачи помогут вам разобраться с такими структурами данных, как массивы, стеки, очереди, множества, словари (объекты), двусвязные и односвязные списки.
1️⃣ Работа с массивами: Сумма элементов массива
⌛ Задача: Напишите функцию, которая принимает массив чисел и возвращает их сумму.
🎯 Решение:
```js
function sumArray(arr) {
  return arr.reduce((acc, val) => acc + val, 0);
}

console.log(sumArray([1, 2, 3, 4, 5])); // 15
```
Объяснение:
- Используем метод `reduce()` для суммирования всех элементов массива. Он принимает два параметра: аккумулятор и текущий элемент. Изначально аккумулятор равен 0.
---
2️⃣ Стек: Реализация стека
⌛ Задача: Реализуйте стек с методами `push`, `pop` и `peek` (посмотреть верхний элемент).
🎯 Решение:
```js
class Stack {
  constructor() {
    this.items = [];
  }

  push(element) {
    this.items.push(element);
  }

  pop() {
    return this.items.pop();
  }

  peek() {
    return this.items[this.items.length - 1];
  }

  isEmpty() {
    return this.items.length === 0;
  }
}

const stack = new Stack();
stack.push(10);
stack.push(20);
console.log(stack.peek()); // 20
stack.pop();
console.log(stack.peek()); // 10
```
Объяснение:
- Стек работает по принципу LIFO (последний вошёл — первый вышел). Мы реализуем методы для добавления, удаления и получения верхнего элемента.
---
3️⃣ Очередь: Реализация очереди
⌛ Задача: Реализуйте очередь с методами `enqueue`, `dequeue`, `peek`.
🎯 Решение:
```js
class Queue {
  constructor() {
    this.items = [];
  }

  enqueue(element) {
    this.items.push(element);
  }

  dequeue() {
    return this.items.shift();
  }

  peek() {
    return this.items[0];
  }

  isEmpty() {
    return this.items.length === 0;
  }
}

const queue = new Queue();
queue.enqueue(10);
queue.enqueue(20);
console.log(queue.peek()); // 10
queue.dequeue();
console.log(queue.peek()); // 20
```
Объяснение:
- Очередь работает по принципу FIFO (первый вошёл — первый вышел). Мы добавляем элемент в конец очереди и удаляем из начала.
---
4️⃣ Множество: Уникальные элементы
⌛ Задача: Напишите функцию, которая принимает массив и возвращает массив с уникальными элементами.
🎯 Решение:
```js
function getUnique(arr) {
  return [...new Set(arr)];
}

console.log(getUnique([1, 2, 2, 3, 4, 4, 5])); // [1, 2, 3, 4, 5]
```
Объяснение:
- Множество (`Set`) автоматически удаляет дубликаты. Мы используем его для создания массива уникальных элементов.
---
5️⃣ Словарь (Объект): Подсчёт частоты элементов
⌛ Задача: Напишите функцию, которая подсчитывает частоту появления каждого элемента в массиве и возвращает объект.
🎯 Решение:
```js
function countFrequency(arr) {
  let frequency = {};
  arr.forEach(item => {
    frequency[item] = (frequency[item] || 0) + 1;
  });
  return frequency;
}

console.log(countFrequency([1, 2, 2, 3, 3, 3])); // {1: 1, 2: 2, 3: 3}
```
Объяснение:
- Используем объект как словарь, где ключи — это элементы массива, а значения — это их частота появления. В цикле увеличиваем счётчик для каждого элемента.
---
6️⃣ Односвязный список: Добавление элемента
⌛ Задача: Реализуйте односвязный список и добавьте элемент в конец списка.
🎯 Решение:
```js
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class SinglyLinkedList {
  constructor() {
    this.head = null;
  }

  add(value) {
    const newNode = new Node(value);
    if (this.head === null) {
      this.head = newNode;
    } else {
      let current = this.head;
      while (current.next !== null) {
        current = current.next;
      }
      current.next = newNode;
    }
  }

  print() {
    let current = this.head;
    let result = '';
    while (current !== null) {
      result += current.data + ' -> ';
      current = current.next;
    }
    console.log(result.slice(0, -4));
  }
}

const list = new SinglyLinkedList();
list.add(10);
list.add(20);
list.add(30);
list.print(); // 10 -> 20 -> 30
```
Объяснение:
- В этом примере мы реализуем односвязный список. Метод `add` добавляет новый узел в конец списка, обновляя указатель последнего узла.
---
7️⃣ Двусвязный список: Добавление элемента в начало
⌛ Задача: Реализуйте двусвязный список и добавьте элемент в начало.
🎯 Решение:
```js
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
    this.prev = null;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;
  }

  addToFront(value) {
    const newNode = new Node(value);
    if (this.head === null) {
      this.head = newNode;
    } else {
      newNode.next = this.head;
      this.head.prev = newNode;
      this.head = newNode;
    }
  }

  print() {
    let current = this.head;
    let result = '';
    while (current !== null) {
      result += current.data + ' <-> ';
      current = current.next;
    }
    console.log(result.slice(0, -4));
  }
}

const list = new DoublyLinkedList();
list.addToFront(10);
list.addToFront(20);
list.addToFront(30);
list.print(); // 30 <-> 20 <-> 10
```
Объяснение:
- В двусвязном списке каждый узел хранит ссылки как на следующий элемент, так и на предыдущий. Метод `addToFront` добавляет новый узел в начало списка.
---
8️⃣ Приоритетная очередь: Реализация очереди с приоритетом
⌛ Задача: Реализуйте приоритетную очередь с методами `enqueue` и `dequeue`, где элементы с большим приоритетом обрабатываются раньше.
🎯 Решение:
```js
class PriorityQueue {
  constructor() {
    this.items = [];
  }

  enqueue(element, priority) {
    const newNode = { element, priority };
    if (this.items.length === 0) {
      this.items.push(newNode);
    } else {
      let added = false;
      for (let i = 0; i < this.items.length; i++) {
        if (newNode.priority > this.items[i].priority) {
          this.items.splice(i, 0, newNode);
          added = true;
          break;
        }
      }
      if (!added) {
        this.items.push(newNode);
      }
    }
  }

  dequeue() {
    return this.items.shift();
  }

  peek() {
    return this.items[0];
  }
}

const pq = new PriorityQueue();
pq.enqueue('task1', 1);
pq.enqueue('task2', 3);
pq.enqueue('task3', 2);
console.log(pq.peek()); // { element: 'task2', priority: 3 }
pq.dequeue();
console.log(pq.peek()); // { element: 'task3', priority: 2 }
```
Объяснение:
- Приоритетная очередь использует сортировку элементов по приоритету. Метод `enqueue` добавляет элемент в очередь с учётом его приоритета.
---
9️⃣ Хеш-таблица: Операции вставки и поиска
⌛ Задача: Реализуйте простую хеш-таблицу с методами вставки и поиска.
🎯 Решение:
```js
class HashTable {
  constructor(size = 4) {
    this.table = new Array(size);
  }

  hash(key) {
    let hash = 0;
    for (let i = 0; i < key.length; i++) {
      hash += key.charCodeAt(i);
    }
    return hash % this.table.length;
  }

  insert(key, value) {
    const index = this.hash(key);
    this.table[index] = value;
  }

  search(key) {
    const index = this.hash(key);
    return this.table[index];
  }
}

const hashTable = new HashTable();
hashTable.insert('name', 'John');
hashTable.insert('age', 30);
console.log(hashTable.search('name')); // John
```
Объяснение:
- Хеш-таблица использует хеш-функцию для вычисления индекса элемента. В этой простейшей версии данные сохраняются в массиве.
---
🔟 Алгоритм сортировки слиянием
⌛ Задача: Напишите функцию для сортировки массива с использованием алгоритма сортировки слиянием.
🎯 Решение:
```js
function mergeSort(arr) {
  if (arr.length <= 1) return arr;

  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));

  return merge(left, right);
}

function merge(left, right) {
  let result = [];
  let i = 0, j = 0;

  while (i < left.length && j < right.length) {
    if (left[i] < right[j]) {
      result.push(left[i]);
      i++;
    } else {
      result.push(right[j]);
      j++;
    }
  }

  return result.concat(left.slice(i)).concat(right.slice(j));
}

console.log(mergeSort([10, 2, 3, 4, 1])); // [1, 2, 3, 4, 10]
```
Объяснение:
- Алгоритм сортировки слиянием делит массив на более мелкие части, сортирует их рекурсивно и затем сливает отсортированные части в один отсортированный массив.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& 
---------------------
⋙ ❍ Односвязный список:
---
Односвязный список — это структура данных, где каждый элемент (узел) содержит данные и ссылку на следующий узел. Списки часто используются для эффективной работы с динамически изменяющимися данными.
1️⃣ Реализация односвязного списка
⌛ Задача: Создать структуру данных для односвязного списка с методами для добавления элементов в конец списка.
🎯 Решение:
```js
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class SinglyLinkedList {
  constructor() {
    this.head = null;
  }

  add(value) {
    const newNode = new Node(value);
    if (this.head === null) {
      this.head = newNode;
    } else {
      let current = this.head;
      while (current.next !== null) {
        current = current.next;
      }
      current.next = newNode;
    }
  }

  print() {
    let current = this.head;
    let result = '';
    while (current !== null) {
      result += current.data + ' -> ';
      current = current.next;
    }
    console.log(result.slice(0, -4));
  }
}

const list = new SinglyLinkedList();
list.add(10);
list.add(20);
list.add(30);
list.print(); // 10 -> 20 -> 30
```
Объяснение:
- Создали два класса: `Node` (узел) и `SinglyLinkedList` (список).
- Метод `add()` добавляет новые элементы в конец списка.
---
2️⃣ Добавление элемента в начало списка
⌛ Задача: Написать метод для добавления элемента в начало односвязного списка.
🎯 Решение:
```js
class SinglyLinkedList {
  constructor() {
    this.head = null;
  }

  addToFront(value) {
    const newNode = new Node(value);
    newNode.next = this.head;
    this.head = newNode;
  }

  print() {
    let current = this.head;
    let result = '';
    while (current !== null) {
      result += current.data + ' -> ';
      current = current.next;
    }
    console.log(result.slice(0, -4));
  }
}

const list = new SinglyLinkedList();
list.addToFront(10);
list.addToFront(20);
list.addToFront(30);
list.print(); // 30 -> 20 -> 10
```
Объяснение:
- Метод `addToFront()` добавляет новый элемент в начало списка, меняя ссылку на голову списка.
---
3️⃣ Удаление элемента из начала списка
⌛ Задача: Написать метод для удаления элемента из начала списка.
🎯 Решение:
```js
class SinglyLinkedList {
  constructor() {
    this.head = null;
  }

  removeFromFront() {
    if (this.head !== null) {
      this.head = this.head.next;
    }
  }

  print() {
    let current = this.head;
    let result = '';
    while (current !== null) {
      result += current.data + ' -> ';
      current = current.next;
    }
    console.log(result.slice(0, -4));
  }
}

const list = new SinglyLinkedList();
list.addToFront(10);
list.addToFront(20);
list.addToFront(30);
list.print(); // 30 -> 20 -> 10
list.removeFromFront();
list.print(); // 20 -> 10
```
Объяснение:
- Метод `removeFromFront()` удаляет первый элемент, изменяя ссылку на голову списка.
---
4️⃣ Поиск элемента в списке
⌛ Задача: Написать метод для поиска элемента в списке.
🎯 Решение:
```js
class SinglyLinkedList {
  constructor() {
    this.head = null;
  }

  add(value) {
    const newNode = new Node(value);
    if (this.head === null) {
      this.head = newNode;
    } else {
      let current = this.head;
      while (current.next !== null) {
        current = current.next;
      }
      current.next = newNode;
    }
  }

  find(value) {
    let current = this.head;
    while (current !== null) {
      if (current.data === value) {
        return true;
      }
      current = current.next;
    }
    return false;
  }

  print() {
    let current = this.head;
    let result = '';
    while (current !== null) {
      result += current.data + ' -> ';
      current = current.next;
    }
    console.log(result.slice(0, -4));
  }
}

const list = new SinglyLinkedList();
list.add(10);
list.add(20);
list.add(30);
list.print(); // 10 -> 20 -> 30
console.log(list.find(20)); // true
console.log(list.find(40)); // false
```
Объяснение:
- Метод `find()` ищет элемент в списке, перебирая его узлы.
---
5️⃣ Удаление элемента из списка по значению
⌛ Задача: Написать метод для удаления элемента из списка по значению.
🎯 Решение:
```js
class SinglyLinkedList {
  constructor() {
    this.head = null;
  }

  add(value) {
    const newNode = new Node(value);
    if (this.head === null) {
      this.head = newNode;
    } else {
      let current = this.head;
      while (current.next !== null) {
        current = current.next;
      }
      current.next = newNode;
    }
  }

  remove(value) {
    if (this.head === null) return;
    if (this.head.data === value) {
      this.head = this.head.next;
      return;
    }
    let current = this.head;
    while (current.next !== null && current.next.data !== value) {
      current = current.next;
    }
    if (current.next !== null) {
      current.next = current.next.next;
    }
  }

  print() {
    let current = this.head;
    let result = '';
    while (current !== null) {
      result += current.data + ' -> ';
      current = current.next;
    }
    console.log(result.slice(0, -4));
  }
}

const list = new SinglyLinkedList();
list.add(10);
list.add(20);
list.add(30);
list.print(); // 10 -> 20 -> 30
list.remove(20);
list.print(); // 10 -> 30
```
Объяснение:
- Метод `remove()` удаляет элемент, если он существует в списке. Если элемент находится в середине или в конце, обновляется ссылка на следующий элемент.
---
6️⃣ Получение элемента по индексу
⌛ Задача: Написать метод для получения элемента по индексу в списке.
🎯 Решение:
```js
class SinglyLinkedList {
  constructor() {
    this.head = null;
  }

  add(value) {
    const newNode = new Node(value);
    if (this.head === null) {
      this.head = newNode;
    } else {
      let current = this.head;
      while (current.next !== null) {
        current = current.next;
      }
      current.next = newNode;
    }
  }

  get(index) {
    let current = this.head;
    let counter = 0;
    while (current !== null) {
      if (counter === index) {
        return current.data;
      }
      current = current.next;
      counter++;
    }
    return null; // если индекс выходит за пределы списка
  }

  print() {
    let current = this.head;
    let result = '';
    while (current !== null) {
      result += current.data + ' -> ';
      current = current.next;
    }
    console.log(result.slice(0, -4));
  }
}

const list = new SinglyLinkedList();
list.add(10);
list.add(20);
list.add(30);
console.log(list.get(1)); // 20
```
Объяснение:
- Метод `get()` перебирает список и возвращает данные элемента на указанном индексе.
---
7️⃣ Реверс односвязного списка
⌛ Задача: Написать метод для реверсирования (переворачивания) односвязного списка.
🎯 Решение:
```js
class SinglyLinkedList {
  constructor() {
    this.head = null;
  }

  add(value) {
    const newNode = new Node(value);
    if (this.head === null) {
      this.head = newNode;
    } else {
      let current = this.head;
      while (current.next !== null) {
        current = current.next;
      }
      current.next = newNode;
    }
  }

  reverse() {
    let prev = null;
    let current = this.head;
    while (current !== null) {
      let nextNode = current.next;
      current.next = prev;
      prev = current;
      current = nextNode;
    }
    this.head = prev;
  }

  print() {
    let current = this.head;
    let result = '';
    while (current !== null) {
      result += current.data + ' -> ';
      current = current.next;
    }
    console.log(result.slice(0, -4));
  }
}

const list = new SinglyLinkedList();
list.add(10);
list.add(20);
list.add(30);
list.print(); // 10 -> 20 -> 30
list.reverse();
list.print(); // 30 -> 20 -> 10
```
Объяснение:
- Метод `reverse()` меняет направление всех ссылок в списке, превращая его в обратный.
---
8️⃣ Проверка пустоты списка
⌛ Задача: Написать метод для проверки, пуст ли список.
🎯 Решение:
```js
class SinglyLinkedList {
  constructor() {
    this.head = null;
  }

  isEmpty() {
    return this.head === null;
  }

  print() {
    let current = this.head;
    let result = '';
    while (current !== null) {
      result += current.data + ' -> ';
      current = current.next;
    }
    console.log(result.slice(0, -4));
  }
}

const list = new SinglyLinkedList();
console.log(list.isEmpty()); // true
list.add(10);
console.log(list.isEmpty()); // false
```
Объяснение:
- Метод `isEmpty()` проверяет, является ли голова списка `null`, что означает, что список пуст.
---
9️⃣ Объединение двух списков
⌛ Задача: Написать метод для объединения двух односвязных списков.
🎯 Решение:
```js
class SinglyLinkedList {
  constructor() {
    this.head = null;
  }

  add(value) {
    const newNode = new Node(value);
    if (this.head === null) {
      this.head = newNode;
    } else {
      let current = this.head;
      while (current.next !== null) {
        current = current.next;
      }
      current.next = newNode;
    }
  }

  merge(otherList) {
    let current = this.head;
    while (current && current.next !== null) {
      current = current.next;
    }
    if (current !== null) {
      current.next = otherList.head;
    } else {
      this.head = otherList.head;
    }
  }

  print() {
    let current = this.head;
    let result = '';
    while (current !== null) {
      result += current.data + ' -> ';
      current = current.next;
    }
    console.log(result.slice(0, -4));
  }
}

const list1 = new SinglyLinkedList();
const list2 = new SinglyLinkedList();
list1.add(10);
list1.add(20);
list2.add(30);
list2.add(40);
list1.merge(list2);
list1.print(); // 10 -> 20 -> 30 -> 40
```
Объяснение:
- Метод `merge()` объединяет два списка, соединяя конец первого списка с началом второго.
---
🔟 Подсчёт элементов в списке
⌛ Задача: Написать метод для подсчёта количества элементов в односвязном списке.
🎯 Решение:
```js
class SinglyLinkedList {
  constructor() {
    this.head = null;
  }

  count() {
    let current = this.head;
    let count = 0;
    while (current !== null) {
      count++;
      current = current.next;
    }
    return count;
  }

  print() {
    let current = this.head;
    let result = '';
    while (current !== null) {
      result += current.data + ' -> ';
      current = current.next;
    }
    console.log(result.slice(0, -4));
  }
}

const list = new SinglyLinkedList();
list.add(10);
list.add(20);
list.add(30);
console.log(list.count()); // 3
```
Объяснение:
- Метод `count()` перебирает список и увеличивает счётчик для каждого узла, возвращая количество элементов в списке.
Односвязный список — это мощная структура данных, которая позволяет эффективно добавлять, удалять и манипулировать элементами, но с затратами на произвольный доступ.
---------------------
⋙ ❍ Множество:
---
Множество — это структура данных, которая хранит уникальные значения. В JavaScript для работы с множествами используется встроенный объект `Set`. Множества не содержат повторяющихся элементов, и их элементы не упорядочены.
1️⃣ Создание множества и добавление элементов
⌛ Задача: Реализовать множество и добавить в него несколько элементов.
🎯 Решение:
```js
const set = new Set();
set.add(1);
set.add(2);
set.add(3);
console.log(set); // Set { 1, 2, 3 }
```
Объяснение:
- Множество создается с помощью конструктора `Set()`.
- Метод `add()` добавляет элементы в множество.
- В множестве не может быть повторяющихся значений.
---
2️⃣ Проверка наличия элемента в множестве
⌛ Задача: Написать функцию для проверки, существует ли элемент в множестве.
🎯 Решение:
```js
const set = new Set([1, 2, 3]);
console.log(set.has(2)); // true
console.log(set.has(5)); // false
```
Объяснение:
- Метод `has()` проверяет наличие элемента в множестве.
- Если элемент существует, возвращается `true`, если нет — `false`.
---
3️⃣ Удаление элемента из множества
⌛ Задача: Написать функцию для удаления элемента из множества.
🎯 Решение:
```js
const set = new Set([1, 2, 3]);
set.delete(2);
console.log(set); // Set { 1, 3 }
```
Объяснение:
- Метод `delete()` удаляет элемент из множества.
- Если элемент существует, он будет удален, иначе множество остается без изменений.
---
4️⃣ Очищение множества
⌛ Задача: Написать метод для очистки множества (удаления всех элементов).
🎯 Решение:
```js
const set = new Set([1, 2, 3]);
set.clear();
console.log(set); // Set {}
```
Объяснение:
- Метод `clear()` удаляет все элементы из множества, делая его пустым.
---
5️⃣ Перебор всех элементов множества
⌛ Задача: Написать метод для перебора всех элементов множества и вывода их на экран.
🎯 Решение:
```js
const set = new Set([1, 2, 3]);
set.forEach(value => console.log(value));
// 1
// 2
// 3
```
Объяснение:
- Метод `forEach()` используется для перебора всех элементов множества и выполнения функции для каждого элемента.
---
6️⃣ Получение размера множества
⌛ Задача: Написать функцию для получения количества элементов в множестве.
🎯 Решение:
```js
const set = new Set([1, 2, 3, 4]);
console.log(set.size); // 4
```
Объяснение:
- Свойство `size` возвращает количество элементов в множестве.
---
7️⃣ Объединение двух множеств
⌛ Задача: Написать функцию для объединения двух множеств.
🎯 Решение:
```js
const set1 = new Set([1, 2, 3]);
const set2 = new Set([3, 4, 5]);
const union = new Set([...set1, ...set2]);
console.log(union); // Set { 1, 2, 3, 4, 5 }
```
Объяснение:
- Для объединения двух множеств мы используем оператор распространения (`...`), который распаковывает элементы из каждого множества и собирает их в новое множество.
---
8️⃣ Пересечение двух множеств
⌛ Задача: Написать функцию для нахождения пересечения двух множеств.
🎯 Решение:
```js
const set1 = new Set([1, 2, 3]);
const set2 = new Set([3, 4, 5]);
const intersection = new Set([...set1].filter(x => set2.has(x)));
console.log(intersection); // Set { 3 }
```
Объяснение:
- Для нахождения пересечения используем метод `filter()`, чтобы отфильтровать только те элементы, которые есть в обоих множествах.
---
9️⃣ Разность двух множеств
⌛ Задача: Написать функцию для нахождения разности двух множеств (элементы, которые есть в первом множестве, но отсутствуют во втором).
🎯 Решение:
```js
const set1 = new Set([1, 2, 3, 4]);
const set2 = new Set([3, 4, 5]);
const difference = new Set([...set1].filter(x => !set2.has(x)));
console.log(difference); // Set { 1, 2 }
```
Объяснение:
- Для нахождения разности используем метод `filter()`, чтобы отфильтровать элементы, которые есть в первом множестве, но нет во втором.
---
🔟 Симметрическая разность двух множеств
⌛ Задача: Написать функцию для нахождения симметрической разности двух множеств (элементы, которые есть в одном множестве, но отсутствуют в другом).
🎯 Решение:
```js
const set1 = new Set([1, 2, 3, 4]);
const set2 = new Set([3, 4, 5, 6]);
const symmetricDifference = new Set([
  ...[...set1].filter(x => !set2.has(x)),
  ...[...set2].filter(x => !set1.has(x))
]);
console.log(symmetricDifference); // Set { 1, 2, 5, 6 }
```
Объяснение:
- Симметрическая разность состоит из элементов, которые есть в одном из двух множеств, но отсутствуют в другом.
- Для этого используем два фильтра: один для элементов из первого множества, другой — для элементов из второго.
Множества в JavaScript являются полезной структурой данных, которая позволяет работать с уникальными элементами. С помощью методов `add()`, `delete()`, `has()`, а также с использованием операторов для объединения, пересечения и разности множеств, можно легко манипулировать данными.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& 
